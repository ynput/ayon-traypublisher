var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"TrayPublisher addon","text":"<p>TrayPublisher is a simple host integration in AYON to publish products out of DCCs.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_traypublisher<ul> <li>addon</li> <li>api<ul> <li>editorial</li> <li>main</li> <li>pipeline</li> <li>plugin</li> </ul> </li> <li>batch_parsing</li> <li>csv_publish</li> <li>plugins<ul> <li>create<ul> <li>create_colorspace_look</li> <li>create_csv_ingest</li> <li>create_editorial_advanced</li> <li>create_editorial_package</li> <li>create_editorial_simple</li> <li>create_from_settings</li> <li>create_movie_batch</li> <li>create_online</li> </ul> </li> <li>publish<ul> <li>collect_app_name</li> <li>collect_clip_instances</li> <li>collect_colorspace_look</li> <li>collect_csv_ingest_instance_data</li> <li>collect_editorial_instances</li> <li>collect_editorial_package</li> <li>collect_editorial_reviewable</li> <li>collect_explicit_colorspace</li> <li>collect_frame_data_from_folder_entity</li> <li>collect_movie_batch</li> <li>collect_online_file</li> <li>collect_review_frames</li> <li>collect_sequence_frame_data</li> <li>collect_shot_instances</li> <li>collect_simple_instances</li> <li>collect_source</li> <li>extract_colorspace_look</li> <li>extract_csv_file</li> <li>extract_editorial_pckg</li> <li>extract_trim_video_audio</li> <li>validate_colorspace</li> <li>validate_colorspace_look</li> <li>validate_editorial_package</li> <li>validate_existing_version</li> <li>validate_filepaths</li> <li>validate_frame_ranges</li> <li>validate_online_file</li> </ul> </li> </ul> </li> <li>ui<ul> <li>window</li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>creator_plugins</li> <li>editorial_creators</li> <li>imageio</li> <li>main</li> <li>publish_plugins</li> <li>simple_creators</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_traypublisher/index.html","title":"ayon_traypublisher","text":""},{"location":"autoapi/client/ayon_traypublisher/index.html#client.ayon_traypublisher.TrayPublishAddon","title":"<code>TrayPublishAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code>, <code>ITrayAction</code>, <code>IPluginPaths</code></p> Source code in <code>client/ayon_traypublisher/addon.py</code> <pre><code>class TrayPublishAddon(\n    AYONAddon, IHostAddon, ITrayAction, IPluginPaths\n):\n    label = \"Publisher\"\n    name = \"traypublisher\"\n    version = __version__\n    host_name = \"traypublisher\"\n\n    _choose_dialog = None\n\n    def tray_init(self):\n        return\n\n    def get_plugin_paths(self):\n        return {}\n\n    def get_publish_plugin_paths(self, host_name):\n        output = []\n        if host_name == self.host_name:\n            output.append(\n                os.path.join(TRAYPUBLISH_ROOT_DIR, \"plugins\", \"publish\")\n            )\n        return output\n\n    def get_create_plugin_paths(self, host_name):\n        output = []\n        if host_name == self.host_name:\n            output.append(\n                os.path.join(TRAYPUBLISH_ROOT_DIR, \"plugins\", \"create\")\n            )\n        return output\n\n    def on_action_trigger(self):\n        self._show_choose_project()\n\n    def cli(self, click_group):\n        cli_main = click_wrap.group(\n            self._cli_main,\n            name=self.name,\n            help=\"TrayPublisher commands\"\n        )\n\n        cli_main.command(\n            self._cli_launch,\n            name=\"launch\",\n            help=\"Launch TrayPublish tool UI.\",\n        ).option(\n            \"--project\",\n            help=\"Project name\",\n            envvar=\"AYON_PROJECT_NAME\",\n            default=None,\n        )\n\n        cli_main.command(\n            self._cli_ingest_csv,\n            name=\"ingestcsv\",\n        ).option(\n            \"--filepath\",\n            help=\"Full path to CSV file with data\",\n            type=str,\n            required=True\n        ).option(\n            \"--project\",\n            help=\"Project name in which the context will be used\",\n            type=str,\n            required=True\n        ).option(\n            \"--folder-path\",\n            help=\"Asset name in which the context will be used\",\n            type=str,\n            required=True\n        ).option(\n            \"--task\",\n            help=\"Task name under Asset in which the context will be used\",\n            type=str,\n            required=False\n        ).option(\n            \"--ignore-validators\",\n            help=\"Option to ignore validators\",\n            type=bool,\n            is_flag=True,\n            required=False\n        )\n        click_group.add_command(cli_main.to_click_obj())\n\n    def _cli_main(self):\n        pass\n\n    def _cli_launch(self, project: Optional[str] = None):\n        from .api.main import launch_traypublisher_ui\n\n        launch_traypublisher_ui(self, project)\n\n    def _start_traypublisher(self, project_name: str):\n        args = get_ayon_launcher_args(\n            \"addon\", self.name, \"launch\", \"--project\", project_name\n        )\n        env = os.environ.copy()\n        env[\"AYON_PROJECT_NAME\"] = project_name\n        run_detached_process(args, env=env)\n\n    def _get_choose_dialog(self):\n        if self._choose_dialog is None:\n            from ayon_traypublisher.ui import ChooseProjectWindow\n\n            choose_dialog = ChooseProjectWindow()\n            choose_dialog.accepted.connect(self._on_choose_dialog_accept)\n            self._choose_dialog = choose_dialog\n        return self._choose_dialog\n\n    def _on_choose_dialog_accept(self):\n        project_name = self._choose_dialog.get_selected_project_name()\n        if project_name:\n            self._start_traypublisher(project_name)\n\n    def _show_choose_project(self):\n        from qtpy import QtCore\n\n        window = self._get_choose_dialog()\n        window.show()\n        window.setWindowState(\n            window.windowState()\n            &amp; ~QtCore.Qt.WindowMinimized\n            | QtCore.Qt.WindowActive\n        )\n        window.activateWindow()\n\n    def _cli_ingest_csv(\n        self,\n        filepath,\n        project,\n        folder_path,\n        task,\n        ignore_validators,\n    ):\n        \"\"\"Ingest CSV file into project.\n\n        This command will ingest CSV file into project. CSV file must be in\n        specific format. See documentation for more information.\n        \"\"\"\n        from .csv_publish import csvpublish\n\n        # Allow user override through AYON_USERNAME when\n        # current connection is made through a service user.\n        username = os.environ.get(\"AYON_USERNAME\")\n        if username:\n            con = ayon_api.get_server_api_connection()\n            if con.is_service_user():\n                con.set_default_service_username(username)\n\n        # use Path to check if csv_filepath exists\n        if not Path(filepath).exists():\n            raise FileNotFoundError(f\"File {filepath} does not exist.\")\n\n        csvpublish(\n            filepath,\n            project,\n            folder_path,\n            task,\n            ignore_validators\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_traypublisher/addon.html#client.ayon_traypublisher.addon.TrayPublishAddon","title":"<code>TrayPublishAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code>, <code>ITrayAction</code>, <code>IPluginPaths</code></p> Source code in <code>client/ayon_traypublisher/addon.py</code> <pre><code>class TrayPublishAddon(\n    AYONAddon, IHostAddon, ITrayAction, IPluginPaths\n):\n    label = \"Publisher\"\n    name = \"traypublisher\"\n    version = __version__\n    host_name = \"traypublisher\"\n\n    _choose_dialog = None\n\n    def tray_init(self):\n        return\n\n    def get_plugin_paths(self):\n        return {}\n\n    def get_publish_plugin_paths(self, host_name):\n        output = []\n        if host_name == self.host_name:\n            output.append(\n                os.path.join(TRAYPUBLISH_ROOT_DIR, \"plugins\", \"publish\")\n            )\n        return output\n\n    def get_create_plugin_paths(self, host_name):\n        output = []\n        if host_name == self.host_name:\n            output.append(\n                os.path.join(TRAYPUBLISH_ROOT_DIR, \"plugins\", \"create\")\n            )\n        return output\n\n    def on_action_trigger(self):\n        self._show_choose_project()\n\n    def cli(self, click_group):\n        cli_main = click_wrap.group(\n            self._cli_main,\n            name=self.name,\n            help=\"TrayPublisher commands\"\n        )\n\n        cli_main.command(\n            self._cli_launch,\n            name=\"launch\",\n            help=\"Launch TrayPublish tool UI.\",\n        ).option(\n            \"--project\",\n            help=\"Project name\",\n            envvar=\"AYON_PROJECT_NAME\",\n            default=None,\n        )\n\n        cli_main.command(\n            self._cli_ingest_csv,\n            name=\"ingestcsv\",\n        ).option(\n            \"--filepath\",\n            help=\"Full path to CSV file with data\",\n            type=str,\n            required=True\n        ).option(\n            \"--project\",\n            help=\"Project name in which the context will be used\",\n            type=str,\n            required=True\n        ).option(\n            \"--folder-path\",\n            help=\"Asset name in which the context will be used\",\n            type=str,\n            required=True\n        ).option(\n            \"--task\",\n            help=\"Task name under Asset in which the context will be used\",\n            type=str,\n            required=False\n        ).option(\n            \"--ignore-validators\",\n            help=\"Option to ignore validators\",\n            type=bool,\n            is_flag=True,\n            required=False\n        )\n        click_group.add_command(cli_main.to_click_obj())\n\n    def _cli_main(self):\n        pass\n\n    def _cli_launch(self, project: Optional[str] = None):\n        from .api.main import launch_traypublisher_ui\n\n        launch_traypublisher_ui(self, project)\n\n    def _start_traypublisher(self, project_name: str):\n        args = get_ayon_launcher_args(\n            \"addon\", self.name, \"launch\", \"--project\", project_name\n        )\n        env = os.environ.copy()\n        env[\"AYON_PROJECT_NAME\"] = project_name\n        run_detached_process(args, env=env)\n\n    def _get_choose_dialog(self):\n        if self._choose_dialog is None:\n            from ayon_traypublisher.ui import ChooseProjectWindow\n\n            choose_dialog = ChooseProjectWindow()\n            choose_dialog.accepted.connect(self._on_choose_dialog_accept)\n            self._choose_dialog = choose_dialog\n        return self._choose_dialog\n\n    def _on_choose_dialog_accept(self):\n        project_name = self._choose_dialog.get_selected_project_name()\n        if project_name:\n            self._start_traypublisher(project_name)\n\n    def _show_choose_project(self):\n        from qtpy import QtCore\n\n        window = self._get_choose_dialog()\n        window.show()\n        window.setWindowState(\n            window.windowState()\n            &amp; ~QtCore.Qt.WindowMinimized\n            | QtCore.Qt.WindowActive\n        )\n        window.activateWindow()\n\n    def _cli_ingest_csv(\n        self,\n        filepath,\n        project,\n        folder_path,\n        task,\n        ignore_validators,\n    ):\n        \"\"\"Ingest CSV file into project.\n\n        This command will ingest CSV file into project. CSV file must be in\n        specific format. See documentation for more information.\n        \"\"\"\n        from .csv_publish import csvpublish\n\n        # Allow user override through AYON_USERNAME when\n        # current connection is made through a service user.\n        username = os.environ.get(\"AYON_USERNAME\")\n        if username:\n            con = ayon_api.get_server_api_connection()\n            if con.is_service_user():\n                con.set_default_service_username(username)\n\n        # use Path to check if csv_filepath exists\n        if not Path(filepath).exists():\n            raise FileNotFoundError(f\"File {filepath} does not exist.\")\n\n        csvpublish(\n            filepath,\n            project,\n            folder_path,\n            task,\n            ignore_validators\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/batch_parsing.html","title":"batch_parsing","text":"<p>Functions to parse asset names, versions from file names</p>"},{"location":"autoapi/client/ayon_traypublisher/batch_parsing.html#client.ayon_traypublisher.batch_parsing.get_folder_by_name_case_not_sensitive","title":"<code>get_folder_by_name_case_not_sensitive(project_name, folder_name, all_selected_folder_ids=None, log=None)</code>","text":"<p>Handle more cases in file names</p> Source code in <code>client/ayon_traypublisher/batch_parsing.py</code> <pre><code>def get_folder_by_name_case_not_sensitive(\n    project_name,\n    folder_name,\n    all_selected_folder_ids=None,\n    log=None\n):\n    \"\"\"Handle more cases in file names\"\"\"\n    if not log:\n        log = Logger.get_logger(__name__)\n    folder_name = re.compile(folder_name, re.IGNORECASE)\n\n    folder_entities = list(ayon_api.get_folders(\n        project_name,\n        folder_ids=all_selected_folder_ids,\n        folder_names=[folder_name]\n    ))\n\n    if len(folder_entities) &gt; 1:\n        log.warning(\"Too many records found for {}\".format(\n            folder_name))\n        return None\n\n    if folder_entities:\n        return folder_entities.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/batch_parsing.html#client.ayon_traypublisher.batch_parsing.get_folder_entity_from_filename","title":"<code>get_folder_entity_from_filename(project_name, source_filename, version_regex, all_selected_folder_ids=None)</code>","text":"<p>Try to parse out folder name from file name provided.</p> <p>Artists might provide various file name formats. Currently handled:     - chair.mov     - chair_v001.mov     - my_chair_to_upload.mov</p> Source code in <code>client/ayon_traypublisher/batch_parsing.py</code> <pre><code>def get_folder_entity_from_filename(\n    project_name,\n    source_filename,\n    version_regex,\n    all_selected_folder_ids=None\n):\n    \"\"\"Try to parse out folder name from file name provided.\n\n    Artists might provide various file name formats.\n    Currently handled:\n        - chair.mov\n        - chair_v001.mov\n        - my_chair_to_upload.mov\n    \"\"\"\n    version = None\n    folder_name = os.path.splitext(source_filename)[0]\n    # Always first check if source filename is directly folder\n    #   (eg. 'chair.mov')\n    matching_folder_entity = get_folder_by_name_case_not_sensitive(\n        project_name, folder_name, all_selected_folder_ids)\n\n    if matching_folder_entity is None:\n        # name contains also a version\n        matching_folder_entity, version = (\n            parse_with_version(\n                project_name,\n                folder_name,\n                version_regex,\n                all_selected_folder_ids\n            )\n        )\n\n    if matching_folder_entity is None:\n        matching_folder_entity = parse_containing(\n            project_name,\n            folder_name,\n            all_selected_folder_ids\n        )\n\n    return matching_folder_entity, version\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/batch_parsing.html#client.ayon_traypublisher.batch_parsing.parse_containing","title":"<code>parse_containing(project_name, folder_name, all_selected_folder_ids=None)</code>","text":"<p>Look if file name contains any existing folder name</p> Source code in <code>client/ayon_traypublisher/batch_parsing.py</code> <pre><code>def parse_containing(project_name, folder_name, all_selected_folder_ids=None):\n    \"\"\"Look if file name contains any existing folder name\"\"\"\n    for folder_entity in ayon_api.get_folders(\n        project_name,\n        folder_ids=all_selected_folder_ids,\n        fields={\"id\", \"name\"}\n    ):\n        if folder_entity[\"name\"].lower() in folder_name.lower():\n            return ayon_api.get_folder_by_id(\n                project_name,\n                folder_entity[\"id\"]\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/batch_parsing.html#client.ayon_traypublisher.batch_parsing.parse_with_version","title":"<code>parse_with_version(project_name, folder_name, version_regex, all_selected_folder_ids=None, log=None)</code>","text":"<p>Try to parse folder name from a file name containing version too</p> <p>Eg. 'chair_v001.mov' &gt;&gt; 'chair', 1</p> Source code in <code>client/ayon_traypublisher/batch_parsing.py</code> <pre><code>def parse_with_version(\n    project_name,\n    folder_name,\n    version_regex,\n    all_selected_folder_ids=None,\n    log=None\n):\n    \"\"\"Try to parse folder name from a file name containing version too\n\n    Eg. 'chair_v001.mov' &gt;&gt; 'chair', 1\n    \"\"\"\n    if not log:\n        log = Logger.get_logger(__name__)\n    log.debug(\n        (\"Folder entity by \\\"{}\\\" was not found, trying version regex.\".\n         format(folder_name)))\n\n    matching_folder_entity = version_number = None\n\n    regex_result = version_regex.findall(folder_name)\n    if regex_result:\n        _folder_name, _version_number = regex_result[0]\n        matching_folder_entity = get_folder_by_name_case_not_sensitive(\n            project_name,\n            _folder_name,\n            all_selected_folder_ids=all_selected_folder_ids\n        )\n        if matching_folder_entity:\n            version_number = int(_version_number)\n\n    return matching_folder_entity, version_number\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/csv_publish.html","title":"csv_publish","text":""},{"location":"autoapi/client/ayon_traypublisher/csv_publish.html#client.ayon_traypublisher.csv_publish.csvpublish","title":"<code>csvpublish(filepath, project_name, folder_path, task_name=None, ignore_validators=False)</code>","text":"<p>Publish CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSV file.</p> required <code>project_name</code> <code>str</code> <p>Project name.</p> required <code>folder_path</code> <code>str</code> <p>Folder path.</p> required <code>task_name</code> <code>Optional[str]</code> <p>Task name.</p> <code>None</code> <code>ignore_validators</code> <code>Optional[bool]</code> <p>Option to ignore validators.</p> <code>False</code> Source code in <code>client/ayon_traypublisher/csv_publish.py</code> <pre><code>def csvpublish(\n    filepath,\n    project_name,\n    folder_path,\n    task_name=None,\n    ignore_validators=False\n):\n    \"\"\"Publish CSV file.\n\n    Args:\n        filepath (str): Path to CSV file.\n        project_name (str): Project name.\n        folder_path (str): Folder path.\n        task_name (Optional[str]): Task name.\n        ignore_validators (Optional[bool]): Option to ignore validators.\n\n    \"\"\"\n    os.environ[\"AYON_PROJECT_NAME\"] = project_name\n\n    # initialization of host\n    host = TrayPublisherHost()\n    install_host(host)\n\n    # form precreate data with field values\n    file_field = FileDefItem.from_paths([filepath], False).pop().to_dict()\n    precreate_data = {\n        \"csv_filepath_data\": file_field,\n    }\n\n    # create context initialization\n    create_context = CreateContext(host, headless=True)\n    folder_entity = create_context.get_folder_entity(folder_path)\n\n    if not folder_entity:\n        ValueError(\n            f\"Folder path '{folder_path}' doesn't \"\n            f\"exists at project '{project_name}'.\"\n        )\n\n    task_entity = create_context.get_task_entity(\n        folder_path,\n        task_name,\n    )\n\n    if not task_entity:\n        ValueError(\n            f\"Task name '{task_name}' doesn't \"\n            f\"exists at folder '{folder_path}'.\"\n        )\n\n    create_context.create(\n        \"io.ayon.creators.traypublisher.csv_ingest\",\n        \"Main\",\n        folder_entity=folder_entity,\n        task_entity=task_entity,\n        pre_create_data=precreate_data,\n    )\n\n    # publishing context initialization\n    pyblish_context = pyblish.api.Context()\n    pyblish_context.data[\"create_context\"] = create_context\n\n    targets = None\n    # redefine targets (skip 'local' to disable validators)\n    if ignore_validators:\n        targets = [\"default\", \"ingest\"]\n\n    # publishing\n    pyblish.util.publish(context=pyblish_context, targets=targets)\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/version.html","title":"version","text":"<p>Package declaring AYON addon 'traypublisher' version.</p>"},{"location":"autoapi/client/ayon_traypublisher/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_traypublisher/api/index.html#client.ayon_traypublisher.api.TrayPublisherHost","title":"<code>TrayPublisherHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_traypublisher/api/pipeline.py</code> <pre><code>class TrayPublisherHost(HostBase, IPublishHost):\n    name = \"traypublisher\"\n\n    def install(self):\n        os.environ[\"AYON_HOST_NAME\"] = self.name\n\n        pyblish.api.register_host(\"traypublisher\")\n\n    def get_context_title(self):\n        return self.get_current_project_name()\n\n    def get_context_data(self):\n        return HostContext.get_context_data()\n\n    def update_context_data(self, data, changes):\n        HostContext.save_context_data(data)\n\n    def set_project_name(self, project_name: str):\n        \"\"\"Change project name.\n\n        DEPRECATED:\n            TrayPublisher now expects that project name is set before\n                is started, and is not possible to change project during\n                process lifetime.\n\n        \"\"\"\n        warnings.warn(\n            (\n                \"'set_project_name' is deprecated and will be removed\"\n                \" in future versions of TrayPublisher addon.\"\n                \" Project name should be set before TrayPublisher is started.\"\n            ),\n            DeprecationWarning,\n        )\n        os.environ[\"AYON_PROJECT_NAME\"] = project_name\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/index.html#client.ayon_traypublisher.api.TrayPublisherHost.set_project_name","title":"<code>set_project_name(project_name)</code>","text":"<p>Change project name.</p> DEPRECATED <p>TrayPublisher now expects that project name is set before     is started, and is not possible to change project during     process lifetime.</p> Source code in <code>client/ayon_traypublisher/api/pipeline.py</code> <pre><code>def set_project_name(self, project_name: str):\n    \"\"\"Change project name.\n\n    DEPRECATED:\n        TrayPublisher now expects that project name is set before\n            is started, and is not possible to change project during\n            process lifetime.\n\n    \"\"\"\n    warnings.warn(\n        (\n            \"'set_project_name' is deprecated and will be removed\"\n            \" in future versions of TrayPublisher addon.\"\n            \" Project name should be set before TrayPublisher is started.\"\n        ),\n        DeprecationWarning,\n    )\n    os.environ[\"AYON_PROJECT_NAME\"] = project_name\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/editorial.html","title":"editorial","text":""},{"location":"autoapi/client/ayon_traypublisher/api/editorial.html#client.ayon_traypublisher.api.editorial.ShotMetadataSolver","title":"<code>ShotMetadataSolver</code>","text":"<p>Solving hierarchical metadata</p> <p>Used during editorial publishing. Works with input clip name and settings defining python formatable template. Settings also define searching patterns and its token keys used for formatting in templates.</p> Source code in <code>client/ayon_traypublisher/api/editorial.py</code> <pre><code>class ShotMetadataSolver:\n    \"\"\" Solving hierarchical metadata\n\n    Used during editorial publishing. Works with input\n    clip name and settings defining python formatable\n    template. Settings also define searching patterns\n    and its token keys used for formatting in templates.\n    \"\"\"\n\n    NO_DECOR_PATERN = re.compile(r\"\\{([a-z]*?)\\}\")\n\n    def __init__(self, logger):\n        self.clip_name_tokenizer = []\n        self.shot_rename = {\n            \"enabled\": False,\n            \"shot_rename_template\": \"\",\n        }\n        self.shot_hierarchy = {\n            \"enabled\": False,\n            \"parents\": [],\n            \"parents_path\": \"\",\n        }\n        self.shot_add_tasks = []\n        self.log = logger\n\n    def update_data(\n        self,\n        clip_name_tokenizer,\n        shot_rename,\n        shot_hierarchy,\n        shot_add_tasks\n    ):\n        self.clip_name_tokenizer = clip_name_tokenizer\n        self.shot_rename = shot_rename\n        self.shot_hierarchy = shot_hierarchy\n        self.shot_add_tasks = shot_add_tasks\n\n    def _rename_template(self, data):\n        \"\"\"Shot renaming function\n\n        Args:\n            data (dict): formatting data\n\n        Raises:\n            CreatorError: If missing keys\n\n        Returns:\n            str: formatted new name\n        \"\"\"\n        shot_rename_template = self.shot_rename[\n            \"shot_rename_template\"]\n        try:\n            # format to new shot name\n            return shot_rename_template.format(**data)\n        except KeyError as _error:\n            raise CreatorError((\n                \"Make sure all keys in settings are correct:: \\n\\n\"\n                f\"From template string {shot_rename_template} &gt; \"\n                f\"`{_error}` has no equivalent in \\n\"\n                f\"{list(data.keys())} input formatting keys!\"\n            ))\n\n    def _generate_tokens(self, clip_name, source_data):\n        \"\"\"Token generator\n\n        Settings defines token pairs key and regex expression.\n\n        Args:\n            clip_name (str): name of clip in editorial\n            source_data (dict): data for formatting\n\n        Raises:\n            CreatorError: if missing key\n\n        Returns:\n            dict: updated source_data\n        \"\"\"\n        output_data = deepcopy(source_data[\"anatomy_data\"])\n        output_data[\"clip_name\"] = clip_name\n\n        if not self.clip_name_tokenizer:\n            return output_data\n\n        parent_name = source_data[\"selected_folder_entity\"][\"name\"]\n\n        search_text = parent_name + clip_name\n\n        for clip_name_item in self.clip_name_tokenizer:\n            token_key = clip_name_item[\"name\"]\n            pattern = clip_name_item[\"regex\"]\n            p = re.compile(pattern)\n            match = p.findall(search_text)\n            if not match:\n                raise CreatorError((\n                    \"Make sure regex expression works with your data: \\n\\n\"\n                    f\"'{token_key}' with regex '{pattern}' in your settings\\n\"\n                    \"can't find any match in your clip name \"\n                    f\"'{search_text}'!\\n\\nLook to: \"\n                    \"'project_settings/traypublisher/editorial_creators\"\n                    \"/editorial_simple/clip_name_tokenizer'\\n\"\n                    \"at your project settings...\"\n                ))\n\n            #  QUESTION:how to refactor `match[-1]` to some better way?\n            output_data[token_key] = match[-1]\n\n        return output_data\n\n    def _create_parents_from_settings(self, parents, data):\n        \"\"\"formatting parent components.\n\n        Args:\n            parents (list): list of dict parent components\n            data (dict): formatting data\n\n        Raises:\n            CreatorError: missing formatting key\n            CreatorError: missing token key\n            KeyError: missing parent token\n\n        Returns:\n            list: list of dict of parent components\n        \"\"\"\n        # fill the parents parts from presets\n        shot_hierarchy = deepcopy(self.shot_hierarchy)\n        hierarchy_parents = shot_hierarchy[\"parents\"]\n\n        # fill parent keys data template from anatomy data\n        try:\n            _parent_tokens_formatting_data = {\n                parent_token[\"name\"]: parent_token[\"value\"].format(**data)\n                for parent_token in hierarchy_parents\n            }\n        except KeyError as _error:\n            raise CreatorError((\n                \"Make sure all keys in settings are correct : \\n\"\n                f\"`{_error}` has no equivalent in \\n{list(data.keys())}\"\n            ))\n\n        _parent_tokens_type = {\n            parent_token[\"name\"]: parent_token[\"parent_type\"]\n            for parent_token in hierarchy_parents\n        }\n        for _index, _parent in enumerate(\n            shot_hierarchy[\"parents_path\"].split(\"/\")\n        ):\n            # format parent token with value which is formatted\n            try:\n                parent_name = _parent.format(\n                    **_parent_tokens_formatting_data)\n            except KeyError as _error:\n                raise CreatorError((\n                    \"Make sure all keys in settings are correct:\\n\\n\"\n                    f\"`{_error}` from template string\"\n                    f\" {shot_hierarchy['parents_path']},\"\n                    f\" has no equivalent in\"\n                    f\"\\n{list(_parent_tokens_formatting_data.keys())} parents\"\n                ))\n\n            parent_token_name = (\n                self.NO_DECOR_PATERN.findall(_parent).pop())\n\n            if not parent_token_name:\n                raise KeyError(\n                    f\"Parent token is not found in: `{_parent}`\")\n\n            # find parent type\n            parent_token_type = _parent_tokens_type[parent_token_name]\n\n            # in case selected context is set to the same folder\n            # TODO keep index with 'parents' - name check is not enough\n            if (\n                _index == 0\n                and parents[-1][\"entity_name\"] == parent_name\n            ):\n                continue\n\n            # in case first parent is project then start parents from start\n            if (\n                _index == 0\n                and parent_token_type.lower() == \"project\"\n            ):\n                project_parent = parents[0]\n                parents = [project_parent]\n                continue\n\n            parents.append({\n                \"entity_type\": \"folder\",\n                \"folder_type\": parent_token_type.lower(),\n                \"entity_name\": parent_name\n            })\n\n        return parents\n\n    def _create_hierarchy_path(self, parents):\n        \"\"\"Converting hierarchy path from parents\n\n        Args:\n            parents (list): list of dict parent components\n\n        Returns:\n            str: hierarchy path\n        \"\"\"\n        return \"/\".join(\n            [\n                p[\"entity_name\"] for p in parents\n                if p[\"entity_type\"] != \"project\"\n            ]\n        ) if parents else \"\"\n\n    def _get_parents_from_selected_folder(\n        self,\n        project_entity,\n        folder_entity,\n    ):\n        \"\"\"Returning parents from context on selected folder.\n\n        Context defined in Traypublisher project tree.\n\n        Args:\n            project_entity (dict[str, Any]): Project entity.\n            folder_entity (dict[str, Any]): Selected folder entity.\n\n        Returns:\n            list: list of dict parent components\n        \"\"\"\n\n        project_name = project_entity[\"name\"]\n        path_entries = folder_entity[\"path\"].split(\"/\")\n        subpaths = []\n        subpath_items = []\n        for name in path_entries:\n            subpath_items.append(name)\n            if name:\n                subpaths.append(\"/\".join(subpath_items))\n        # Remove last name because we already have folder entity\n        subpaths.pop(-1)\n\n        folder_entity_by_path = {}\n        if subpaths:\n            folder_entity_by_path = {\n                parent_folder[\"path\"]: parent_folder\n                for parent_folder in ayon_api.get_folders(\n                    project_name, folder_paths=subpaths\n                )\n            }\n        folders_hierarchy = [\n            folder_entity_by_path[folder_path]\n            for folder_path in subpaths\n        ]\n        folders_hierarchy.append(folder_entity)\n\n        # add current selection context hierarchy\n        output = [{\n            \"entity_type\": \"project\",\n            \"entity_name\": project_name,\n        }]\n        for entity in folders_hierarchy:\n            output.append({\n                \"entity_type\": \"folder\",\n                \"folder_type\": entity[\"folderType\"],\n                \"entity_name\": entity[\"name\"]\n            })\n        return output\n\n    def _generate_tasks_from_settings(self, project_entity):\n        \"\"\"Convert settings inputs to task data.\n\n        Args:\n            project_entity (dict): Project entity.\n\n        Raises:\n            KeyError: Missing task type in project doc\n\n        Returns:\n            dict: tasks data\n        \"\"\"\n        tasks_to_add = {}\n\n        project_task_types = project_entity[\"taskTypes\"]\n        task_type_names = {\n            task_type[\"name\"]\n            for task_type in project_task_types\n        }\n        for task_item in self.shot_add_tasks:\n            task_name = task_item[\"name\"]\n            task_type = task_item[\"task_type\"]\n\n            # check if task type in project task types\n            if task_type not in task_type_names:\n                raise KeyError(\n                    \"Missing task type `{}` for `{}` is not\"\n                    \" existing in `{}``\".format(\n                        task_type,\n                        task_name,\n                        list(task_type_names)\n                    )\n                )\n            tasks_to_add[task_name] = {\"type\": task_type}\n\n        return tasks_to_add\n\n    def generate_data(self, clip_name, source_data):\n        \"\"\"Metadata generator.\n\n        Converts input data to hierarchy mentadata.\n\n        Args:\n            clip_name (str): clip name\n            source_data (dict): formatting data\n\n        Returns:\n            (str, dict): shot name and hierarchy data\n        \"\"\"\n\n        tasks = {}\n        folder_entity = source_data[\"selected_folder_entity\"]\n        project_entity = source_data[\"project_entity\"]\n\n        # match clip to shot name at start\n        shot_name = clip_name\n\n        # parse all tokens and generate formatting data\n        formatting_data = self._generate_tokens(shot_name, source_data)\n\n        # generate parents from selected folder\n        parents = self._get_parents_from_selected_folder(\n            project_entity, folder_entity\n        )\n\n        if self.shot_rename[\"enabled\"]:\n            shot_name = self._rename_template(formatting_data)\n            self.log.info(f\"Renamed shot name: {shot_name}\")\n\n        if self.shot_hierarchy[\"enabled\"]:\n            parents = self._create_parents_from_settings(\n                parents, formatting_data)\n\n        if self.shot_add_tasks:\n            tasks = self._generate_tasks_from_settings(\n                project_entity)\n\n        # generate hierarchy path from parents\n        hierarchy_path = self._create_hierarchy_path(parents)\n        if hierarchy_path:\n            folder_path = f\"/{hierarchy_path}/{shot_name}\"\n        else:\n            folder_path = f\"/{shot_name}\"\n\n        return shot_name, {\n            \"hierarchy\": hierarchy_path,\n            \"folderPath\": folder_path,\n            \"parents\": parents,\n            \"tasks\": tasks\n        }\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/editorial.html#client.ayon_traypublisher.api.editorial.ShotMetadataSolver.generate_data","title":"<code>generate_data(clip_name, source_data)</code>","text":"<p>Metadata generator.</p> <p>Converts input data to hierarchy mentadata.</p> <p>Parameters:</p> Name Type Description Default <code>clip_name</code> <code>str</code> <p>clip name</p> required <code>source_data</code> <code>dict</code> <p>formatting data</p> required <p>Returns:</p> Type Description <code>(str, dict)</code> <p>shot name and hierarchy data</p> Source code in <code>client/ayon_traypublisher/api/editorial.py</code> <pre><code>def generate_data(self, clip_name, source_data):\n    \"\"\"Metadata generator.\n\n    Converts input data to hierarchy mentadata.\n\n    Args:\n        clip_name (str): clip name\n        source_data (dict): formatting data\n\n    Returns:\n        (str, dict): shot name and hierarchy data\n    \"\"\"\n\n    tasks = {}\n    folder_entity = source_data[\"selected_folder_entity\"]\n    project_entity = source_data[\"project_entity\"]\n\n    # match clip to shot name at start\n    shot_name = clip_name\n\n    # parse all tokens and generate formatting data\n    formatting_data = self._generate_tokens(shot_name, source_data)\n\n    # generate parents from selected folder\n    parents = self._get_parents_from_selected_folder(\n        project_entity, folder_entity\n    )\n\n    if self.shot_rename[\"enabled\"]:\n        shot_name = self._rename_template(formatting_data)\n        self.log.info(f\"Renamed shot name: {shot_name}\")\n\n    if self.shot_hierarchy[\"enabled\"]:\n        parents = self._create_parents_from_settings(\n            parents, formatting_data)\n\n    if self.shot_add_tasks:\n        tasks = self._generate_tasks_from_settings(\n            project_entity)\n\n    # generate hierarchy path from parents\n    hierarchy_path = self._create_hierarchy_path(parents)\n    if hierarchy_path:\n        folder_path = f\"/{hierarchy_path}/{shot_name}\"\n    else:\n        folder_path = f\"/{shot_name}\"\n\n    return shot_name, {\n        \"hierarchy\": hierarchy_path,\n        \"folderPath\": folder_path,\n        \"parents\": parents,\n        \"tasks\": tasks\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/main.html","title":"main","text":""},{"location":"autoapi/client/ayon_traypublisher/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_traypublisher/api/pipeline.html#client.ayon_traypublisher.api.pipeline.TrayPublisherHost","title":"<code>TrayPublisherHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_traypublisher/api/pipeline.py</code> <pre><code>class TrayPublisherHost(HostBase, IPublishHost):\n    name = \"traypublisher\"\n\n    def install(self):\n        os.environ[\"AYON_HOST_NAME\"] = self.name\n\n        pyblish.api.register_host(\"traypublisher\")\n\n    def get_context_title(self):\n        return self.get_current_project_name()\n\n    def get_context_data(self):\n        return HostContext.get_context_data()\n\n    def update_context_data(self, data, changes):\n        HostContext.save_context_data(data)\n\n    def set_project_name(self, project_name: str):\n        \"\"\"Change project name.\n\n        DEPRECATED:\n            TrayPublisher now expects that project name is set before\n                is started, and is not possible to change project during\n                process lifetime.\n\n        \"\"\"\n        warnings.warn(\n            (\n                \"'set_project_name' is deprecated and will be removed\"\n                \" in future versions of TrayPublisher addon.\"\n                \" Project name should be set before TrayPublisher is started.\"\n            ),\n            DeprecationWarning,\n        )\n        os.environ[\"AYON_PROJECT_NAME\"] = project_name\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/pipeline.html#client.ayon_traypublisher.api.pipeline.TrayPublisherHost.set_project_name","title":"<code>set_project_name(project_name)</code>","text":"<p>Change project name.</p> DEPRECATED <p>TrayPublisher now expects that project name is set before     is started, and is not possible to change project during     process lifetime.</p> Source code in <code>client/ayon_traypublisher/api/pipeline.py</code> <pre><code>def set_project_name(self, project_name: str):\n    \"\"\"Change project name.\n\n    DEPRECATED:\n        TrayPublisher now expects that project name is set before\n            is started, and is not possible to change project during\n            process lifetime.\n\n    \"\"\"\n    warnings.warn(\n        (\n            \"'set_project_name' is deprecated and will be removed\"\n            \" in future versions of TrayPublisher addon.\"\n            \" Project name should be set before TrayPublisher is started.\"\n        ),\n        DeprecationWarning,\n    )\n    os.environ[\"AYON_PROJECT_NAME\"] = project_name\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_traypublisher/api/plugin.html#client.ayon_traypublisher.api.plugin.HiddenTrayPublishCreator","title":"<code>HiddenTrayPublishCreator</code>","text":"<p>               Bases: <code>HiddenCreator</code></p> Source code in <code>client/ayon_traypublisher/api/plugin.py</code> <pre><code>class HiddenTrayPublishCreator(HiddenCreator):\n    host_name = \"traypublisher\"\n    settings_category = \"traypublisher\"\n\n    def collect_instances(self):\n        instances_by_identifier = cache_and_get_instances(\n            self, SHARED_DATA_KEY, list_instances\n        )\n        for instance_data in instances_by_identifier[self.identifier]:\n            instance = CreatedInstance.from_existing(instance_data, self)\n            self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        update_instances(update_list)\n\n    def remove_instances(self, instances):\n        remove_instances(instances)\n        for instance in instances:\n            self._remove_instance_from_context(instance)\n\n    def _store_new_instance(self, new_instance):\n        \"\"\"Tray publisher specific method to store instance.\n\n        Instance is stored into \"workfile\" of traypublisher and also add it\n        to CreateContext.\n\n        Args:\n            new_instance (CreatedInstance): Instance that should be stored.\n        \"\"\"\n\n        # Host implementation of storing metadata about instance\n        HostContext.add_instance(new_instance.data_to_store())\n        # Add instance to current context\n        self._add_instance_to_context(new_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/plugin.html#client.ayon_traypublisher.api.plugin.SettingsCreator","title":"<code>SettingsCreator</code>","text":"<p>               Bases: <code>TrayPublishCreator</code></p> Source code in <code>client/ayon_traypublisher/api/plugin.py</code> <pre><code>class SettingsCreator(TrayPublishCreator):\n    create_allow_context_change = True\n    create_allow_thumbnail = True\n    allow_version_control = False\n\n    extensions = []\n\n    def create(self, product_name, data, pre_create_data):\n        # Pass precreate data to creator attributes\n        thumbnail_path = pre_create_data.pop(PRE_CREATE_THUMBNAIL_KEY, None)\n\n        # Fill 'version_to_use' if version control is enabled\n        if self.allow_version_control:\n            folder_path = data[\"folderPath\"]\n            product_entities_by_folder_path = self._prepare_next_versions(\n                [folder_path], [product_name])\n            version = product_entities_by_folder_path[folder_path].get(\n                product_name\n            )\n            pre_create_data[\"version_to_use\"] = version\n            data[\"_previous_last_version\"] = version\n\n        data[\"creator_attributes\"] = pre_create_data\n        data[\"settings_creator\"] = True\n\n        # Create new instance\n        new_instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n\n        self._store_new_instance(new_instance)\n\n        if thumbnail_path:\n            self.set_instance_thumbnail_path(new_instance.id, thumbnail_path)\n\n    def _prepare_next_versions(self, folder_paths, product_names):\n        \"\"\"Prepare next versions for given folder and product names.\n\n        Todos:\n            Expect combination of product names by folder path to avoid\n                unnecessary server calls for unused products.\n\n        Args:\n            folder_paths (Iterable[str]): Folder paths.\n            product_names (Iterable[str]): Product names.\n\n        Returns:\n            dict[str, dict[str, int]]: Last versions by fodler path\n                and product names.\n        \"\"\"\n\n        # Prepare all versions for all combinations to '1'\n        # TODO use 'ayon_core.pipeline.version_start' logic\n        product_entities_by_folder_path = {\n            folder_path: {\n                product_name: 1\n                for product_name in product_names\n            }\n            for folder_path in folder_paths\n        }\n        if not folder_paths or not product_names:\n            return product_entities_by_folder_path\n\n        folder_entities = ayon_api.get_folders(\n            self.project_name,\n            folder_paths=folder_paths,\n            fields={\"id\", \"path\"}\n        )\n        folder_paths_by_id = {\n            folder_entity[\"id\"]: folder_entity[\"path\"]\n            for folder_entity in folder_entities\n        }\n        product_entities = list(ayon_api.get_products(\n            self.project_name,\n            folder_ids=folder_paths_by_id.keys(),\n            product_names=product_names,\n            fields={\"id\", \"name\", \"folderId\"}\n        ))\n\n        product_ids = {p[\"id\"] for p in product_entities}\n        last_versions = ayon_api.get_last_versions(\n            self.project_name,\n            product_ids,\n            fields={\"version\", \"productId\"})\n\n        for product_entity in product_entities:\n            product_id = product_entity[\"id\"]\n            product_name = product_entity[\"name\"]\n            folder_id = product_entity[\"folderId\"]\n            folder_path = folder_paths_by_id[folder_id]\n            last_version = last_versions.get(product_id)\n            version = 0\n            if last_version is not None:\n                version = last_version[\"version\"]\n            product_entities_by_folder_path[folder_path][product_name] += (\n                version\n            )\n        return product_entities_by_folder_path\n\n    def _fill_next_versions(self, instances_data):\n        \"\"\"Fill next version for instances.\n\n        Instances have also stored previous next version to be able to\n        recognize if user did enter different version. If version was\n        not changed by user, or user set it to '0' the next version will be\n        updated by current database state.\n        \"\"\"\n\n        filtered_instance_data = []\n        for instance in instances_data:\n            previous_last_version = instance.get(\"_previous_last_version\")\n            creator_attributes = instance[\"creator_attributes\"]\n            use_next_version = creator_attributes.get(\n                \"use_next_version\", True)\n            version = creator_attributes.get(\"version_to_use\", 0)\n            if (\n                use_next_version\n                or version == 0\n                or version == previous_last_version\n            ):\n                filtered_instance_data.append(instance)\n\n        folder_paths = {\n            instance[\"folderPath\"]\n            for instance in filtered_instance_data\n        }\n        product_names = {\n            instance[\"productName\"]\n            for instance in filtered_instance_data}\n        product_entities_by_folder_path = self._prepare_next_versions(\n            folder_paths, product_names\n        )\n        for instance in filtered_instance_data:\n            folder_path = instance[\"folderPath\"]\n            product_name = instance[\"productName\"]\n            version = product_entities_by_folder_path[folder_path][product_name]\n            instance[\"creator_attributes\"][\"version_to_use\"] = version\n            instance[\"_previous_last_version\"] = version\n\n    def collect_instances(self):\n        \"\"\"Collect instances from host.\n\n        Overriden to be able to manage version control attributes. If version\n        control is disabled, the attributes will be removed from instances,\n        and next versions are filled if is version control enabled.\n        \"\"\"\n\n        instances_by_identifier = cache_and_get_instances(\n            self, SHARED_DATA_KEY, list_instances\n        )\n        instances = instances_by_identifier[self.identifier]\n        if not instances:\n            return\n\n        if self.allow_version_control:\n            self._fill_next_versions(instances)\n\n        for instance_data in instances:\n            # Make sure that there are not data related to version control\n            #   if plugin does not support it\n            if not self.allow_version_control:\n                instance_data.pop(\"_previous_last_version\", None)\n                creator_attributes = instance_data[\"creator_attributes\"]\n                creator_attributes.pop(\"version_to_use\", None)\n                creator_attributes.pop(\"use_next_version\", None)\n\n            instance = CreatedInstance.from_existing(instance_data, self)\n            self._add_instance_to_context(instance)\n\n    def get_instance_attr_defs(self):\n        defs = self.get_pre_create_attr_defs()\n        if self.allow_version_control:\n            defs += [\n                UISeparatorDef(),\n                BoolDef(\n                    \"use_next_version\",\n                    default=True,\n                    label=\"Use next version\",\n                ),\n                NumberDef(\n                    \"version_to_use\",\n                    default=1,\n                    minimum=0,\n                    maximum=999,\n                    label=\"Version to use\",\n                )\n            ]\n        return defs\n\n    def get_pre_create_attr_defs(self):\n        # Use same attributes as for instance attributes\n        return [\n            FileDef(\n                \"representation_files\",\n                folders=False,\n                extensions=self.extensions,\n                allow_sequences=self.allow_sequences,\n                single_item=not self.allow_multiple_items,\n                label=\"Representations\",\n            ),\n            FileDef(\n                \"reviewable\",\n                folders=False,\n                extensions=REVIEW_EXTENSIONS,\n                allow_sequences=True,\n                single_item=True,\n                label=\"Reviewable representations\",\n                extensions_label=\"Single reviewable item\"\n            )\n        ]\n\n    @classmethod\n    def from_settings(cls, item_data):\n        identifier = item_data[\"identifier\"]\n        product_type = item_data[\"product_type\"]\n        if not identifier:\n            identifier = \"settings_{}\".format(product_type)\n        return type(\n            \"{}{}\".format(cls.__name__, identifier),\n            (cls, ),\n            {\n                \"product_type\": product_type,\n                \"identifier\": identifier,\n                \"label\": item_data[\"label\"].strip(),\n                \"icon\": item_data[\"icon\"],\n                \"description\": item_data[\"description\"],\n                \"detailed_description\": item_data[\"detailed_description\"],\n                \"extensions\": item_data[\"extensions\"],\n                \"allow_sequences\": item_data[\"allow_sequences\"],\n                \"allow_multiple_items\": item_data[\"allow_multiple_items\"],\n                \"allow_version_control\": item_data.get(\n                    \"allow_version_control\", False),\n                \"default_variants\": item_data[\"default_variants\"],\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/plugin.html#client.ayon_traypublisher.api.plugin.SettingsCreator.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect instances from host.</p> <p>Overriden to be able to manage version control attributes. If version control is disabled, the attributes will be removed from instances, and next versions are filled if is version control enabled.</p> Source code in <code>client/ayon_traypublisher/api/plugin.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Collect instances from host.\n\n    Overriden to be able to manage version control attributes. If version\n    control is disabled, the attributes will be removed from instances,\n    and next versions are filled if is version control enabled.\n    \"\"\"\n\n    instances_by_identifier = cache_and_get_instances(\n        self, SHARED_DATA_KEY, list_instances\n    )\n    instances = instances_by_identifier[self.identifier]\n    if not instances:\n        return\n\n    if self.allow_version_control:\n        self._fill_next_versions(instances)\n\n    for instance_data in instances:\n        # Make sure that there are not data related to version control\n        #   if plugin does not support it\n        if not self.allow_version_control:\n            instance_data.pop(\"_previous_last_version\", None)\n            creator_attributes = instance_data[\"creator_attributes\"]\n            creator_attributes.pop(\"version_to_use\", None)\n            creator_attributes.pop(\"use_next_version\", None)\n\n        instance = CreatedInstance.from_existing(instance_data, self)\n        self._add_instance_to_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/api/plugin.html#client.ayon_traypublisher.api.plugin.TrayPublishCreator","title":"<code>TrayPublishCreator</code>","text":"<p>               Bases: <code>Creator</code></p> Source code in <code>client/ayon_traypublisher/api/plugin.py</code> <pre><code>class TrayPublishCreator(Creator):\n    create_allow_context_change = True\n    host_name = \"traypublisher\"\n    settings_category = \"traypublisher\"\n\n    def collect_instances(self):\n        instances_by_identifier = cache_and_get_instances(\n            self, SHARED_DATA_KEY, list_instances\n        )\n        for instance_data in instances_by_identifier[self.identifier]:\n            instance = CreatedInstance.from_existing(instance_data, self)\n            self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        update_instances(update_list)\n\n    def remove_instances(self, instances):\n        remove_instances(instances)\n        for instance in instances:\n            self._remove_instance_from_context(instance)\n\n    def _store_new_instance(self, new_instance):\n        \"\"\"Tray publisher specific method to store instance.\n\n        Instance is stored into \"workfile\" of traypublisher and also add it\n        to CreateContext.\n\n        Args:\n            new_instance (CreatedInstance): Instance that should be stored.\n        \"\"\"\n\n        # Host implementation of storing metadata about instance\n        HostContext.add_instance(new_instance.data_to_store())\n        new_instance.mark_as_stored()\n\n        # Add instance to current context\n        self._add_instance_to_context(new_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_colorspace_look.html","title":"create_colorspace_look","text":"<p>Creator of colorspace look files.</p> <p>This creator is used to publish colorspace look files thanks to production type <code>ociolook</code>. All files are published as representation.</p>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_colorspace_look.html#client.ayon_traypublisher.plugins.create.create_colorspace_look.CreateColorspaceLook","title":"<code>CreateColorspaceLook</code>","text":"<p>               Bases: <code>TrayPublishCreator</code></p> <p>Creates colorspace look files.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_colorspace_look.py</code> <pre><code>class CreateColorspaceLook(TrayPublishCreator):\n    \"\"\"Creates colorspace look files.\"\"\"\n\n    identifier = \"io.ayon.creators.traypublisher.colorspace_look\"\n    label = \"Colorspace Look\"\n    product_type = \"ociolook\"\n    description = \"Publishes color space look file.\"\n    extensions = [\".cc\", \".cube\", \".3dl\", \".spi1d\", \".spi3d\", \".csp\", \".lut\"]\n    enabled = False\n\n    colorspace_items = [\n        (None, \"Not set\")\n    ]\n    colorspace_attr_show = False\n    config_items = None\n    config_data = None\n\n    def get_detail_description(self):\n        return \"\"\"# Colorspace Look\n\nThis creator publishes color space look file (LUT).\n        \"\"\"\n\n    def get_icon(self):\n        return \"mdi.format-color-fill\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        repr_files = pre_create_data.get(\"luts_file\")\n        if not repr_files:\n            raise CreatorError(\"No files specified\")\n\n        folder_path = instance_data[\"folderPath\"]\n        task_name = instance_data[\"task\"]\n        folder_entity = ayon_api.get_folder_by_path(\n            self.project_name, folder_path)\n\n        task_entity = None\n        if task_name:\n            task_entity = ayon_api.get_task_by_name(\n                self.project_name, folder_entity[\"id\"], task_name\n            )\n\n        product_name = self.get_product_name(\n            project_name=self.project_name,\n            folder_entity=folder_entity,\n            task_entity=task_entity,\n            variant=instance_data[\"variant\"],\n        )\n\n        instance_data[\"creator_attributes\"] = {}\n        for idx, repr_file in enumerate(repr_files):\n            files = repr_file.get(\"filenames\")\n            if not files:\n                # this should never happen\n                raise CreatorError(\"Missing files from representation\")\n\n            instance_data[\"creator_attributes\"][f\"{LUT_KEY_PREFIX}_{idx}\"] = (\n                    (Path(repr_file[\"directory\"]) / files[0]).as_posix()\n            )\n\n        # Create new instance\n        new_instance = CreatedInstance(self.product_type, product_name,\n                                       instance_data, self)\n        new_instance.transient_data[\"config_items\"] = self.config_items\n        new_instance.transient_data[\"config_data\"] = self.config_data\n\n        self._store_new_instance(new_instance)\n\n    def collect_instances(self):\n        super().collect_instances()\n        for instance in self.create_context.instances:\n            if instance.creator_identifier == self.identifier:\n                instance.transient_data[\"config_items\"] = self.config_items\n                instance.transient_data[\"config_data\"] = self.config_data\n\n    def get_attr_defs_for_instance(self, instance):\n        attrs = [\n            EnumDef(\n                \"working_colorspace\",\n                self.colorspace_items,\n                default=\"Not set\",\n                label=\"Working Colorspace\",\n            ),\n        ]\n\n        # Collect all LUT files\n        all_files_url = (\n            key\n            for key in instance.data[\"creator_attributes\"]\n            if key.startswith(LUT_KEY_PREFIX)\n        )\n\n        for idx, _ in enumerate(all_files_url):\n            lut_attrs = [\n                UISeparatorDef(\n                    f\"separator_{idx}\",\n                    label=\"Advanced1\"\n                ),\n                TextDef(\n                    f\"abs_lut_path_{idx}\",\n                    label=\"LUT Path\",\n                ),\n                EnumDef(\n                    f\"input_colorspace_{idx}\",\n                    self.colorspace_items,\n                    default=\"Not set\",\n                    label=\"Input Colorspace\",\n                ),\n                EnumDef(\n                    f\"direction_{idx}\",\n                    [\n                        (None, \"Not set\"),\n                        (\"forward\", \"Forward\"),\n                        (\"inverse\", \"Inverse\")\n                    ],\n                    default=\"Not set\",\n                    label=\"Direction\"\n                ),\n                EnumDef(\n                    f\"interpolation_{idx}\",\n                    [\n                        (None, \"Not set\"),\n                        (\"linear\", \"Linear\"),\n                        (\"tetrahedral\", \"Tetrahedral\"),\n                        (\"best\", \"Best\"),\n                        (\"nearest\", \"Nearest\")\n                    ],\n                    default=\"Not set\",\n                    label=\"Interpolation\"\n                ),\n                EnumDef(\n                    f\"output_colorspace_{idx}\",\n                    self.colorspace_items,\n                    default=\"Not set\",\n                    label=\"Output Colorspace\",\n                )\n            ]\n            attrs.extend(lut_attrs)\n\n        return attrs\n\n    def get_pre_create_attr_defs(self):\n        return [\n            FileDef(\n                \"luts_file\",\n                folders=False,\n                extensions=self.extensions,\n                allow_sequences=False,\n                single_item=False,\n                label=\"Look Up Table File(s)\",\n            )\n        ]\n\n    def apply_settings(self, project_settings):\n        config_data = None\n        try:\n            # This might crash because config path is not available\n            #   for the machine\n            config_data = get_current_context_imageio_config_preset(\n                project_settings=project_settings\n            )\n        except Exception:\n            self.log.warning(\n                \"Failed to get imageio config preset for current context\",\n                exc_info=True\n            )\n\n        if not config_data:\n            self.enabled = False\n            return\n\n        filepath = config_data[\"path\"]\n        config_items = get_ocio_config_colorspaces(filepath)\n        labeled_colorspaces = get_colorspaces_enumerator_items(\n            config_items,\n            include_aliases=True,\n            include_roles=True\n        )\n        self.config_items = config_items\n        self.config_data = config_data\n        self.colorspace_items.extend(labeled_colorspaces)\n        self.enabled = True\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_csv_ingest.html","title":"create_csv_ingest","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_csv_ingest.html#client.ayon_traypublisher.plugins.create.create_csv_ingest.IngestCSV","title":"<code>IngestCSV</code>","text":"<p>               Bases: <code>TrayPublishCreator</code></p> <p>CSV ingest creator class</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_csv_ingest.py</code> <pre><code>class IngestCSV(TrayPublishCreator):\n    \"\"\"CSV ingest creator class\"\"\"\n\n    icon = \"fa.file\"\n\n    label = \"CSV Ingest\"\n    product_type = \"csv_ingest_file\"\n    identifier = \"io.ayon.creators.traypublisher.csv_ingest\"\n\n    default_variants = [\"Main\"]\n\n    description = \"Ingest products' data from CSV file\"\n    detailed_description = \"\"\"\nIngest products' data from CSV file following column and representation\nconfiguration in project settings.\n\"\"\"\n\n    # Position in the list of creators.\n    order = 10\n\n    # settings for this creator\n    columns_config = {}\n    representations_config = {}\n    folder_creation_config = {}\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\n                \"add_review_family\",\n                default=True,\n                label=\"Review\"\n            )\n        ]\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Creating pre-create attributes at creator plugin.\n\n        Returns:\n            list: list of attribute object instances\n        \"\"\"\n        # Use same attributes as for instance attributes\n        return [\n            FileDef(\n                \"csv_filepath_data\",\n                folders=False,\n                extensions=[\".csv\"],\n                allow_sequences=False,\n                single_item=True,\n                label=\"CSV File\",\n            ),\n        ]\n\n    def create(\n        self,\n        product_name: str,\n        instance_data: Dict[str, Any],\n        pre_create_data: Dict[str, Any]\n    ):\n        \"\"\"Create product from each row found in the CSV.\n\n        Args:\n            product_name (str): The subset name.\n            instance_data (dict): The instance data.\n            pre_create_data (dict):\n        \"\"\"\n\n        csv_filepath_data = pre_create_data.get(\"csv_filepath_data\", {})\n\n        csv_dir = csv_filepath_data.get(\"directory\", \"\")\n        if not os.path.exists(csv_dir):\n            raise CreatorError(\n                f\"Directory '{csv_dir}' does not exist.\"\n            )\n        filename = csv_filepath_data.get(\"filenames\", [])\n        self._process_csv_file(\n            product_name, instance_data, csv_dir, filename[0]\n        )\n\n    def _pass_data_to_csv_instance(\n        self,\n        instance_data: Dict[str, Any],\n        staging_dir: str,\n        filename: str\n    ):\n        \"\"\"Pass CSV representation file to instance data\"\"\"\n\n        representation = {\n            \"name\": \"csv\",\n            \"ext\": \"csv\",\n            \"files\": filename,\n            \"stagingDir\": staging_dir,\n            \"stagingDir_persistent\": True,\n        }\n\n        instance_data.update({\n            \"label\": f\"CSV: {filename}\",\n            \"representations\": [representation],\n            \"stagingDir\": staging_dir,\n            \"stagingDir_persistent\": True,\n        })\n\n    def _process_csv_file(\n        self,\n        product_name: str,\n        instance_data: Dict[str, Any],\n        csv_dir: str,\n        filename: str\n    ):\n        \"\"\"Process CSV file.\n\n        Args:\n            product_name (str): The subset name.\n            instance_data (dict): The instance data.\n            csv_dir (str): The csv directory.\n            filename (str): The filename.\n\n        \"\"\"\n        # create new instance from the csv file via self function\n        self._pass_data_to_csv_instance(\n            instance_data,\n            csv_dir,\n            filename\n        )\n\n        csv_instance = CreatedInstance(\n            self.product_type, product_name, instance_data, self\n        )\n\n        csv_instance[\"csvFileData\"] = {\n            \"filename\": filename,\n            \"staging_dir\": csv_dir,\n        }\n\n        # create instances from csv data via self function\n        instances = self._create_instances_from_csv_data(csv_dir, filename)\n        for instance in instances:\n            self._store_new_instance(instance)\n        self._store_new_instance(csv_instance)\n\n    def _resolve_repre_path(\n        self, csv_dir: str, filepath: Union[str, None]\n    ) -&gt; Union[str, None]:\n        if not filepath:\n            return filepath\n\n        # Validate only existence of file directory as filename\n        #   may contain frame specific char (e.g. '%04d' or '####').\n        filedir, filename = os.path.split(filepath)\n        if not filedir or filedir == \".\":\n            # If filedir is empty or \".\" then use same directory as\n            #   csv path\n            filepath = os.path.join(csv_dir, filepath)\n\n        elif not os.path.exists(filedir):\n            # If filepath does not exist, first try to find it in the\n            #   same directory as the csv file is, but keep original\n            #   value otherwise.\n            new_filedir = os.path.join(csv_dir, filedir)\n            if os.path.exists(new_filedir):\n                filepath = os.path.join(new_filedir, filename)\n\n        return filepath\n\n    def _get_folder_type_from_regex_settings(self, folder_name: str) -&gt; str:\n        \"\"\" Get the folder type that matches the regex settings.\n\n        Args:\n            folder_name (str): The folder name.\n\n        Returns:\n            str. The folder type to use.\n        \"\"\"\n        for folder_setting in self.folder_creation_config[\"folder_type_regexes\"]:\n            if re.match(folder_setting[\"regex\"], folder_name):\n                folder_type = folder_setting[\"folder_type\"]\n                return folder_type\n\n        return self.folder_creation_config[\"folder_create_type\"]\n\n    def _compute_parents_data(self, project_name: str, product_item: ProductItem) -&gt; list:\n        \"\"\" Compute parent data when new hierarchy has to be created during the\n            publishing process.\n\n        Args:\n            project_name (str): The project name.\n            product_item (ProductItem): The product item to inspect.\n\n        Returns:\n            list. The parent list if any\n\n        Raise:\n            ValueError: When provided folder_path parent do not exist.\n        \"\"\"\n        parent_folder_names = product_item.folder_path.lstrip(\"/\").split(\"/\")\n        # Rename name of folder itself\n        parent_folder_names.pop(-1)\n        if not parent_folder_names:\n            return []\n\n        parent_paths = []\n        parent_path = \"\"\n        for name in parent_folder_names:\n            path = f\"{parent_path}/{name}\"\n            parent_paths.append(path)\n            parent_path = path\n\n        folders_by_path = {\n            folder[\"path\"]: folder\n            for folder in ayon_api.get_folders(\n                project_name,\n                folder_paths=parent_paths,\n                fields={\"folderType\", \"path\"}\n            )\n        }\n        parent_data = []\n        for path in parent_paths:\n            folder_entity = folders_by_path.get(path)\n            name = path.rsplit(\"/\", 1)[-1]\n\n            # Folder exists, retrieve data from existing.\n            if folder_entity:\n                folder_type = folder_entity[\"folderType\"]\n\n            # Define folder type from settings.\n            else:\n                folder_type = self._get_folder_type_from_regex_settings(name)\n\n            item = {\n                \"entity_name\": name,\n                \"folder_type\": folder_type,\n            }\n            parent_data.append(item)\n\n        return parent_data\n\n\n    def _get_data_from_csv(\n        self, csv_dir: str, filename: str\n    ) -&gt; Dict[str, ProductItem]:\n        \"\"\"Generate instances from the csv file\"\"\"\n        # get current project name and code from context.data\n        project_name = self.create_context.get_current_project_name()\n        csv_path = os.path.join(csv_dir, filename)\n\n        # make sure csv file contains columns from following list\n        required_columns = [\n            column[\"name\"]\n            for column in self.columns_config[\"columns\"]\n            if column[\"required_column\"]\n        ]\n\n        # read csv file\n        with open(csv_path, \"r\") as csv_file:\n            csv_content = csv_file.read()\n\n        # read csv file with DictReader\n        csv_reader = csv.DictReader(\n            StringIO(csv_content),\n            delimiter=self.columns_config[\"csv_delimiter\"]\n        )\n\n        # fix fieldnames\n        # sometimes someone can keep extra space at the start or end of\n        # the column name\n        all_columns = [\n            \" \".join(column.rsplit())\n            for column in csv_reader.fieldnames\n        ]\n\n        # return back fixed fieldnames\n        csv_reader.fieldnames = all_columns\n\n        # check if csv file contains all required columns\n        if any(column not in all_columns for column in required_columns):\n            raise CreatorError(\n                f\"Missing required columns: {required_columns}\"\n            )\n\n        product_items_by_name: Dict[str, ProductItem] = {}\n        for row in csv_reader:\n            _product_item: ProductItem = ProductItem.from_csv_row(\n                self.columns_config, row\n            )\n            unique_name = _product_item.unique_name\n            if unique_name not in product_items_by_name:\n                product_items_by_name[unique_name] = _product_item\n            product_item: ProductItem = product_items_by_name[unique_name]\n            product_item.add_repre_item(\n                RepreItem.from_csv_row(\n                    self.columns_config,\n                    self.representations_config,\n                    row\n                )\n            )\n\n        folder_paths: Set[str] = {\n            product_item.folder_path\n            for product_item in product_items_by_name.values()\n        }\n        folder_ids_by_path: Dict[str, str] = {\n            folder_entity[\"path\"]: folder_entity[\"id\"]\n            for folder_entity in ayon_api.get_folders(\n                project_name, folder_paths=folder_paths, fields={\"id\", \"path\"}\n            )\n        }\n        missing_paths: Set[str] = folder_paths - set(folder_ids_by_path.keys())\n\n        task_names: Set[str] = {\n            product_item.task_name\n            for product_item in product_items_by_name.values()\n        }\n        task_entities_by_folder_id = collections.defaultdict(list)\n        for task_entity in ayon_api.get_tasks(\n            project_name,\n            folder_ids=set(folder_ids_by_path.values()),\n            task_names=task_names,\n            fields={\"folderId\", \"name\", \"taskType\"}\n        ):\n            folder_id = task_entity[\"folderId\"]\n            task_entities_by_folder_id[folder_id].append(task_entity)\n\n        missing_tasks: Set[str] = set()\n        if missing_paths and not self.folder_creation_config[\"enabled\"]:\n            error_msg = (\n                \"Folder creation is disabled but found missing folder(s): %r\" %\n                \",\".join(missing_paths)\n            )\n            raise CreatorError(error_msg)\n\n        for product_item in product_items_by_name.values():\n            folder_path = product_item.folder_path\n\n            if folder_path in missing_paths:\n                product_item.has_promised_context = True\n                product_item.task_type = None\n                product_item.parents = self._compute_parents_data(\n                    project_name,\n                    product_item\n                )\n                continue\n\n            task_name = product_item.task_name\n            folder_id = folder_ids_by_path[folder_path]\n            task_entities = task_entities_by_folder_id[folder_id]\n            task_entity = next(\n                (\n                    task_entity\n                    for task_entity in task_entities\n                    if task_entity[\"name\"] == task_name\n                ),\n                None\n            )\n            if task_entity is None:\n                missing_tasks.add(\"/\".join([folder_path, task_name]))\n            else:\n                product_item.task_type = task_entity[\"taskType\"]\n\n        if missing_tasks:\n            ending = \"\" if len(missing_tasks) == 1 else \"s\"\n            joined_paths = \"\\n\".join(sorted(missing_tasks))\n            raise CreatorError(\n                f\"Task{ending} not found.\\n{joined_paths}\"\n            )\n\n        for product_item in product_items_by_name.values():\n            repre_paths: Set[str] = set()\n            duplicated_paths: Set[str] = set()\n            for repre_item in product_item.repre_items:\n                # Resolve relative paths in csv file\n                repre_item.filepath = self._resolve_repre_path(\n                    csv_dir, repre_item.filepath\n                )\n                repre_item.thumbnail_path = self._resolve_repre_path(\n                    csv_dir, repre_item.thumbnail_path\n                )\n\n                filepath = repre_item.filepath\n                if filepath in repre_paths:\n                    duplicated_paths.add(filepath)\n                repre_paths.add(filepath)\n\n            if duplicated_paths:\n                ending = \"\" if len(duplicated_paths) == 1 else \"s\"\n                joined_names = \"\\n\".join(sorted(duplicated_paths))\n                raise CreatorError(\n                    f\"Duplicate filename{ending} in csv file.\\n{joined_names}\"\n                )\n\n        return product_items_by_name\n\n    def _add_thumbnail_repre(\n        self,\n        thumbnails: Set[str],\n        instance: CreatedInstance,\n        repre_item: RepreItem,\n        multiple_thumbnails: bool,\n    ) -&gt; Union[str, None]:\n        \"\"\"Add thumbnail to instance.\n\n        Add thumbnail as representation and set 'thumbnailPath' if is not set\n            yet.\n\n        Args:\n            thumbnails (Set[str]): Set of all thumbnail paths that should\n                create representation.\n            instance (CreatedInstance): Instance from create plugin.\n            repre_item (RepreItem): Representation item.\n            multiple_thumbnails (bool): There are multiple representations\n                with thumbnail.\n\n        Returns:\n            Uniom[str, None]: Explicit output name for thumbnail\n                representation.\n\n        \"\"\"\n        if not thumbnails:\n            return None\n\n        thumbnail_path = repre_item.thumbnail_path\n        if not thumbnail_path or thumbnail_path not in thumbnails:\n            return None\n\n        thumbnails.remove(thumbnail_path)\n\n        thumb_dir, thumb_file = os.path.split(thumbnail_path)\n        thumb_basename, thumb_ext = os.path.splitext(thumb_file)\n\n        # NOTE 'explicit_output_name' and custom repre name was set only\n        #   when 'multiple_thumbnails' is True and 'review' tag is present.\n        # That was changed to set 'explicit_output_name' is set when\n        #   'multiple_thumbnails' is True.\n        # is_reviewable = \"review\" in repre_item.tags\n\n        repre_name = \"thumbnail\"\n        explicit_output_name = None\n        if multiple_thumbnails:\n            repre_name = f\"thumbnail_{thumb_basename}\"\n            explicit_output_name = repre_item.name\n\n        thumbnail_repre_data = {\n            \"name\": repre_name,\n            \"ext\": thumb_ext.lstrip(\".\"),\n            \"files\": thumb_file,\n            \"stagingDir\": thumb_dir,\n            \"stagingDir_persistent\": True,\n            \"tags\": [\"thumbnail\", \"delete\"],\n        }\n        if explicit_output_name:\n            thumbnail_repre_data[\"outputName\"] = explicit_output_name\n\n        instance[\"prepared_data_for_repres\"].append({\n            \"type\": \"thumbnail\",\n            \"colorspace\": None,\n            \"representation\": thumbnail_repre_data,\n        })\n        # also add thumbnailPath for ayon to integrate\n        if not instance.get(\"thumbnailPath\"):\n            instance[\"thumbnailPath\"] = thumbnail_path\n\n        return explicit_output_name\n\n    def _add_representation(\n        self,\n        instance: CreatedInstance,\n        repre_item: RepreItem,\n        explicit_output_name: Optional[str] = None\n    ):\n        \"\"\"Get representation data\n\n        Args:\n            repre_item (RepreItem): Representation item based on csv row.\n            explicit_output_name (Optional[str]): Explicit output name.\n                For grouping purposes with reviewable components.\n\n        \"\"\"\n        # get extension of file\n        basename: str = os.path.basename(repre_item.filepath)\n        extension: str = os.path.splitext(basename)[-1].lower()\n\n        # validate filepath is having correct extension based on output\n        repre_config_data: Union[Dict[str, Any], None] = None\n        for repre in self.representations_config[\"representations\"]:\n            if repre[\"name\"] == repre_item.name:\n                repre_config_data = repre\n                break\n\n        if not repre_config_data:\n            raise CreatorError(\n                f\"Representation '{repre_item.name}' not found \"\n                \"in config representation data.\"\n            )\n\n        validate_extensions: List[str] = repre_config_data[\"extensions\"]\n        if extension not in validate_extensions:\n            raise CreatorError(\n                f\"File extension '{extension}' not valid for \"\n                f\"output '{validate_extensions}'.\"\n            )\n\n        is_sequence: bool = extension in IMAGE_EXTENSIONS\n        # convert ### string in file name to %03d\n        # this is for correct frame range validation\n        # example: file.###.exr -&gt; file.%03d.exr\n        file_head = basename.split(\".\")[0]\n        if \"#\" in basename:\n            padding = len(basename.split(\"#\")) - 1\n            seq_padding = f\"%0{padding}d\"\n            basename = basename.replace(\"#\" * padding, seq_padding)\n            file_head = basename.split(seq_padding)[0]\n            is_sequence = True\n        elif \"%\" in basename:\n            pattern = re.compile(r\"%\\d+d|%d\")\n            padding = pattern.findall(basename)\n            if not padding:\n                raise CreatorError(\n                    f\"File sequence padding not found in '{basename}'.\"\n                )\n            file_head = basename.split(\"%\")[0]\n            is_sequence = True\n        else:\n            # in case it is still image\n            is_sequence = False\n\n        # make absolute path to file\n        dirname: str = os.path.dirname(repre_item.filepath)\n\n        # check if dirname exists\n        if not os.path.isdir(dirname):\n            raise CreatorError(\n                f\"Directory '{dirname}' does not exist.\"\n            )\n\n        frame_start: Union[int, None] = None\n        frame_end: Union[int, None] = None\n        files: Union[str, List[str]] = basename\n        if is_sequence:\n            # get only filtered files form dirname\n            files_from_dir = [\n                filename\n                for filename in os.listdir(dirname)\n                if filename.startswith(file_head)\n            ]\n            # collect all data from dirname\n            cols, _ = clique.assemble(files_from_dir)\n            if not cols:\n                raise CreatorError(\n                    f\"No collections found in directory '{dirname}'.\"\n                )\n\n            col = cols[0]\n            files = list(col)\n            frame_start = min(col.indexes)\n            frame_end = max(col.indexes)\n\n        tags: List[str] = deepcopy(repre_item.tags)\n        # if slate in repre_data is True then remove one frame from start\n        if repre_item.slate_exists:\n            tags.append(\"has_slate\")\n\n        # get representation data\n        representation_data: Dict[str, Any] = {\n            \"name\": repre_item.name,\n            \"ext\": extension[1:],\n            \"files\": files,\n            \"stagingDir\": dirname,\n            \"stagingDir_persistent\": True,\n            \"tags\": tags,\n        }\n        if extension in VIDEO_EXTENSIONS:\n            representation_data.update({\n                \"fps\": repre_item.fps,\n                \"outputName\": repre_item.name,\n            })\n\n        if explicit_output_name:\n            representation_data[\"outputName\"] = explicit_output_name\n\n        if frame_start:\n            representation_data[\"frameStart\"] = frame_start\n        if frame_end:\n            representation_data[\"frameEnd\"] = frame_end\n\n        instance[\"prepared_data_for_repres\"].append({\n            \"type\": \"media\",\n            \"colorspace\": repre_item.colorspace,\n            \"representation\": representation_data,\n        })\n\n    def _prepare_representations(\n        self, product_item: ProductItem, instance: CreatedInstance\n    ):\n        # Collect thumbnail paths from all representation items\n        #   to check if multiple thumbnails are present.\n        # Once representation is created for certain thumbnail it is removed\n        #   from the set.\n        thumbnails: Set[str] = {\n            repre_item.thumbnail_path\n            for repre_item in product_item.repre_items\n            if repre_item.thumbnail_path\n        }\n        multiple_thumbnails: bool = len(thumbnails) &gt; 1\n\n        for repre_item in product_item.repre_items:\n            explicit_output_name = self._add_thumbnail_repre(\n                thumbnails,\n                instance,\n                repre_item,\n                multiple_thumbnails,\n            )\n\n            # get representation data\n            self._add_representation(\n                instance,\n                repre_item,\n                explicit_output_name\n            )\n\n    def _get_task_type_from_task_name(self, task_name: str):\n        \"\"\" Retrieve task type from task name.\n\n        Args:\n            task_name (str): The task name.\n\n        Returns:\n            str. The task type computed from settings.\n        \"\"\"\n        for task_setting in self.folder_creation_config[\"task_type_regexes\"]:\n            if re.match(task_setting[\"regex\"], task_name):\n                task_type = task_setting[\"task_type\"]\n                break\n        else:\n            task_type = self.folder_creation_config[\"task_create_type\"]\n\n        return task_type\n\n    def _create_instances_from_csv_data(self, csv_dir: str, filename: str):\n        \"\"\"Create instances from csv data\"\"\"\n        # from special function get all data from csv file and convert them\n        # to new instances\n        product_items_by_name: Dict[str, ProductItem] = (\n            self._get_data_from_csv(csv_dir, filename)\n        )\n\n        instances = []\n        project_name: str = self.create_context.get_current_project_name()\n        for product_item in product_items_by_name.values():\n            folder_path: str = product_item.folder_path\n            version: int = product_item.version\n            product_name: str = get_product_name(\n                project_name,\n                product_item.task_name,\n                product_item.task_type,\n                self.host_name,\n                product_item.product_type,\n                product_item.variant\n            )\n\n            if version is not None:\n                label: str = f\"{folder_path}_{product_name}_v{version:&gt;03}\"\n            else:\n                label: str = f\"{folder_path}_{product_name}_v[next]\"\n\n            repre_items: List[RepreItem] = product_item.repre_items\n            first_repre_item: RepreItem = repre_items[0]\n            version_comment: Union[str, None] = next(\n                (\n                    repre_item.comment\n                    for repre_item in repre_items\n                    if repre_item.comment\n                ),\n                None\n            )\n\n            slate_exists: bool = any(\n                repre_item.slate_exists\n                for repre_item in repre_items\n            )\n\n            is_reviewable: bool = any(\n                True\n                for repre_item in repre_items\n                if \"review\" in repre_item.tags\n            )\n\n            families: List[str] = [\"csv_ingest\"]\n            if slate_exists:\n                # adding slate to families mainly for loaders to be able\n                # to filter out slates\n                families.append(\"slate\")\n\n            if is_reviewable:\n                # review family needs to be added for ExtractReview plugin\n                families.append(\"review\")\n\n            instance_data = {\n                \"name\": product_item.instance_name,\n                \"folderPath\": folder_path,\n                \"families\": families,\n                \"label\": label,\n                \"task\": product_item.task_name,\n                \"variant\": product_item.variant,\n                \"source\": \"csv\",\n                \"frameStart\": first_repre_item.frame_start,\n                \"frameEnd\": first_repre_item.frame_end,\n                \"handleStart\": first_repre_item.handle_start,\n                \"handleEnd\": first_repre_item.handle_end,\n                \"fps\": first_repre_item.fps,\n                \"version\": version,\n                \"comment\": version_comment,\n                \"prepared_data_for_repres\": []\n            }\n\n            if product_item.has_promised_context:\n                hierarchy, folder_name = folder_path.rsplit(\"/\", 1)\n                families.append(\"shot\")\n                instance_data.update(\n                    {\n                        \"newHierarchyIntegration\": True,\n                        \"hierarchy\": hierarchy,\n                        \"parents\": product_item.parents,\n                        \"families\": families,\n                        \"heroTrack\": True,\n                    }\n                )\n\n                folder_type = self._get_folder_type_from_regex_settings(folder_name)\n                instance_data[\"folder_type\"] = folder_type\n\n                if product_item.task_name:\n                    task_type = self._get_task_type_from_task_name(\n                        product_item.task_name\n                    )\n                    tasks = instance_data.setdefault(\"tasks\", {})\n                    tasks[product_item.task_name] = {\n                        \"type\": task_type\n                    }\n\n            # create new instance\n            new_instance: CreatedInstance = CreatedInstance(\n                product_item.product_type,\n                product_name,\n                instance_data,\n                self\n            )\n            self._prepare_representations(product_item, new_instance)\n\n            if product_item.has_promised_context:\n                new_instance.transient_data[\"has_promised_context\"] = True\n\n            instances.append(new_instance)\n\n        return instances\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_csv_ingest.html#client.ayon_traypublisher.plugins.create.create_csv_ingest.IngestCSV.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Create product from each row found in the CSV.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>The subset name.</p> required <code>instance_data</code> <code>dict</code> <p>The instance data.</p> required <code>pre_create_data</code> <code>dict</code> required Source code in <code>client/ayon_traypublisher/plugins/create/create_csv_ingest.py</code> <pre><code>def create(\n    self,\n    product_name: str,\n    instance_data: Dict[str, Any],\n    pre_create_data: Dict[str, Any]\n):\n    \"\"\"Create product from each row found in the CSV.\n\n    Args:\n        product_name (str): The subset name.\n        instance_data (dict): The instance data.\n        pre_create_data (dict):\n    \"\"\"\n\n    csv_filepath_data = pre_create_data.get(\"csv_filepath_data\", {})\n\n    csv_dir = csv_filepath_data.get(\"directory\", \"\")\n    if not os.path.exists(csv_dir):\n        raise CreatorError(\n            f\"Directory '{csv_dir}' does not exist.\"\n        )\n    filename = csv_filepath_data.get(\"filenames\", [])\n    self._process_csv_file(\n        product_name, instance_data, csv_dir, filename[0]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_csv_ingest.html#client.ayon_traypublisher.plugins.create.create_csv_ingest.IngestCSV.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Creating pre-create attributes at creator plugin.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of attribute object instances</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_csv_ingest.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Creating pre-create attributes at creator plugin.\n\n    Returns:\n        list: list of attribute object instances\n    \"\"\"\n    # Use same attributes as for instance attributes\n    return [\n        FileDef(\n            \"csv_filepath_data\",\n            folders=False,\n            extensions=[\".csv\"],\n            allow_sequences=False,\n            single_item=True,\n            label=\"CSV File\",\n        ),\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html","title":"create_editorial_advanced","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialAdvancedCreator","title":"<code>EditorialAdvancedCreator</code>","text":"<p>               Bases: <code>TrayPublishCreator</code></p> <p>Advanced Editorial creator class</p> <p>Advanced editorial workflow creator. This creator will process imput editorial file and match its clips to files in folder.</p> <p>Parameters:</p> Name Type Description Default <code>TrayPublishCreator</code> <code>Creator</code> <p>Tray publisher plugin class</p> required Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialAdvancedCreator(TrayPublishCreator):\n    \"\"\"Advanced Editorial creator class\n\n    Advanced editorial workflow creator. This creator will process imput\n    editorial file and match its clips to files in folder.\n\n    Args:\n        TrayPublishCreator (Creator): Tray publisher plugin class\n    \"\"\"\n    enabled = True\n    label = \"Editorial Advanced\"\n    product_type = \"editorial\"\n    identifier = \"editorial_advanced\"\n    default_variants = [\n        \"main\"\n    ]\n    description = \"Editorial files to generate shots.\"\n    detailed_description = \"\"\"\nSupporting publishing new shots to project\nor updating already created. Publishing will create OTIO file.\n\"\"\"\n    icon = \"fa.file\"\n    product_type_presets = []\n\n    def __init__(self, *args, **kwargs):\n        self._shot_metadata_solver = ShotMetadataSolver(self.log)\n        super().__init__(*args, **kwargs)\n\n    def apply_settings(self, project_settings):\n        editorial_creators = deepcopy(\n            project_settings[\"traypublisher\"][\"editorial_creators\"]\n        )\n        creator_settings = editorial_creators[self.identifier]\n\n        self.enabled = creator_settings[\"enabled\"]\n\n        self._shot_metadata_solver.update_data(\n            creator_settings[\"clip_name_tokenizer\"],\n            creator_settings[\"shot_rename\"],\n            creator_settings[\"shot_hierarchy\"],\n            creator_settings[\"shot_add_tasks\"]\n        )\n        self.product_type_presets = creator_settings[\n            \"product_type_advanced_presets\"]\n        self.default_variants = creator_settings[\"default_variants\"]\n\n    def create(self, product_name, instance_data, pre_create_data):\n        allowed_product_type_presets = self._get_allowed_product_type_presets(\n            pre_create_data)\n\n        ignored_keys = set(self.get_product_presets_with_names())\n        ignored_keys |= {\"sequence_filepath_data\", \"folder_path_data\"}\n        clip_instance_properties = {\n            k: v\n            for k, v in pre_create_data.items()\n            if k not in ignored_keys\n        }\n\n        folder_path = instance_data[\"folderPath\"]\n        folder_entity = self.create_context.get_folder_entity(\n            folder_path\n        )\n\n        if folder_entity and pre_create_data[\"fps\"] == \"from_selection\":\n            # get 'fps' from folder attributes\n            fps = folder_entity[\"attrib\"][\"fps\"]\n        else:\n            fps = float(pre_create_data[\"fps\"])\n\n        instance_data[\"fps\"] = fps\n\n        # get path of sequence\n        sequence_paths = self._get_path_from_file_data(\n            pre_create_data[\"sequence_filepath_data\"],\n            multi=True\n        )\n\n        media_folder_paths = self._get_path_from_file_data(\n            pre_create_data[\"folder_path_data\"],\n            multi=True\n        )\n\n        # get all sequences into otio_timelines\n        otio_timelines = []\n        for sequence_path in sequence_paths:\n            sequence_name = os.path.basename(sequence_path)\n            # get otio timeline\n            otio_timeline = self._create_otio_timeline(sequence_path, fps)\n            otio_timelines.append((sequence_name, sequence_path, otio_timeline))\n\n        # Create all clip instances\n        clip_instance_properties.update({\n            \"fps\": fps,\n            \"variant\": instance_data[\"variant\"]\n        })\n\n        ignore_clip_no_content = pre_create_data[\"ignore_clip_no_content\"]\n        for media_folder_path in media_folder_paths:\n            for (sequence_name, sequence_path, otio_timeline) in otio_timelines:\n                # create clip instances\n                self._get_clip_instances(\n                    folder_entity,\n                    otio_timeline,\n                    media_folder_path,\n                    clip_instance_properties,\n                    allowed_product_type_presets,\n                    sequence_name,\n                    ignore_clip_no_content,\n                )\n\n                # create otio editorial instance\n                self._create_otio_instance(\n                    product_name, instance_data, sequence_path, otio_timeline\n                )\n\n    def _create_otio_instance(\n        self, product_name, instance_data, sequence_path, otio_timeline\n    ):\n        \"\"\"Otio instance creating function\n\n        Args:\n            product_name (str): Product name.\n            data (dict): instance data\n            sequence_path (str): path to sequence file\n            otio_timeline (otio.Timeline): otio timeline object\n        \"\"\"\n        # Pass precreate data to creator attributes\n        instance_data.update(\n            {\n                \"sequenceFilePath\": sequence_path,\n                \"otioTimeline\": otio.adapters.write_to_string(otio_timeline),\n            }\n        )\n        new_instance = CreatedInstance(\n            self.product_type, product_name, instance_data, self\n        )\n        self._store_new_instance(new_instance)\n\n    def _create_otio_timeline(self, sequence_path, fps):\n        \"\"\"Creating otio timeline from sequence path\n\n        Args:\n            sequence_path (str): path to sequence file\n            fps (float): frame per second\n\n        Returns:\n            otio.Timeline: otio timeline object\n        \"\"\"\n        # get editorial sequence file into otio timeline object\n        extension = os.path.splitext(sequence_path)[1]\n\n        kwargs = {}\n        if extension.lower() == \".edl\":\n            # EDL has no frame rate embedded so needs explicit\n            # frame rate else 24 is assumed.\n            kwargs[\"rate\"] = fps\n            kwargs[\"ignore_timecode_mismatch\"] = True\n\n        return otio.adapters.read_from_file(sequence_path, **kwargs)\n\n    def _get_path_from_file_data(self, file_path_data, multi=False):\n        \"\"\"Converting creator path data to single path string\n\n        Args:\n            file_path_data (FileDefItem): creator path data inputs\n            multi (bool): switch to multiple files mode\n\n        Raises:\n            FileExistsError: in case nothing had been set\n\n        Returns:\n            Union[list[str], str]: Paths or single path based on\n                'multi' value.\n        \"\"\"\n        output_paths = []\n        for item in file_path_data:\n            dirpath = item[\"directory\"]\n            for filename in item[\"filenames\"]:\n                output_paths.append(os.path.join(dirpath, filename))\n\n        if not output_paths:\n            raise CreatorError(\n                # The message is cryptic even for me might be worth to change\n                f\"File path was not added: {file_path_data}\"\n            )\n        return output_paths if multi else output_paths[0]\n\n    def _get_clip_instances(\n        self,\n        folder_entity,\n        otio_timeline,\n        media_folder_path,\n        instance_data,\n        product_type_presets,\n        sequence_file_name,\n        ignore_clip_no_content,\n    ):\n        \"\"\"Helping function for creating clip instance\n\n        Args:\n            folder_entity (dict[str, Any]): Folder entity.\n            otio_timeline (otio.Timeline): otio timeline object\n            media_folder_path (str): Folder with media files\n            instance_data (dict): clip instance data\n            product_type_presets (list[dict]): list of dict settings\n                product presets\n            sequence_file_name (str): sequence file name\n            ignore_clip_no_content (bool): ignore clips with no content\n        \"\"\"\n        media_folder_path = media_folder_path.replace(\"\\\\\", \"/\")\n\n        # Get all tracks from otio timeline\n        tracks = otio_timeline.video_tracks()\n\n\n        # get all clipnames from otio timeline to list of strings\n        clip_names_set = {clip.name for clip in otio_timeline.find_clips()}\n\n        clip_folders = []\n        # Iterate over all media files in media folder\n        for root, folders, _ in os.walk(media_folder_path):\n            # Use set intersection to find matching folder directly\n            clip_folders.extend(\n                folder\n                for folder in folders\n                if folder in clip_names_set\n            )\n\n        if not clip_folders:\n            self.log.warning(\"No clip folder paths found\")\n            return\n\n        clip_content: Dict[str, Dict[str, list[str]]] = {}\n        # list content of clip folder and search for product items\n        for clip_folder in clip_folders:\n            abs_clip_folder = os.path.join(\n                media_folder_path, clip_folder).replace(\"\\\\\", \"/\")\n\n            matched_product_items = []\n            for root, foldernames, filenames in os.walk(abs_clip_folder):\n                # iterate all product names in enabled presets\n                for pres_product_data in product_type_presets:\n                    product_name = pres_product_data[\"product_name\"]\n\n                    product_data_base = {\n                        \"preset_name\": product_name,\n                        \"clip_dir_subpath\": \"\",\n                        \"product_name\": product_name,\n                        \"files\": [],\n                    }\n                    root = root.replace(\"\\\\\", \"/\")\n                    cl_part_path = root.replace(abs_clip_folder, \"\")\n\n                    for folder in foldernames:\n                        product_data = deepcopy(product_data_base)\n                        # need to include more since variants might occure\n                        pattern_search = re.compile(\n                            f\".*({re.escape(product_name)}{VARIANTS_PATTERN}).*\"\n                        )\n                        match = pattern_search.search(folder)\n                        if not match:\n                            continue\n\n                        # form partial path without starting slash\n                        partial_path = os.path.join(\n                            cl_part_path.lstrip(\"/\"), folder\n                        ).replace(\"\\\\\", \"/\")\n\n                        # update product data it will be deepcopied later\n                        # later in files processor\n                        product_data.update(\n                            {\n                                \"product_name\": match.group(0),\n                                \"clip_dir_subpath\": partial_path,\n                            }\n                        )\n                        nested_files = list(\n                                os.listdir(os.path.join(root, folder)))\n                        self._include_files_for_processing(\n                            product_name,\n                            nested_files,\n                            product_data,\n                            matched_product_items,\n                            strict=False,\n                        )\n\n                    product_data_base[\"clip_dir_subpath\"] = \"/\"\n                    self._include_files_for_processing(\n                        product_name,\n                        filenames,\n                        product_data_base,\n                        matched_product_items,\n                    )\n\n                # No matching product data can be skipped\n                if not matched_product_items:\n                    self.log.warning(\n                        f\"No matching product data found in {root}.\"\n                        \" Skipping folder.\"\n                    )\n                    continue\n\n                clip_content[clip_folder] = matched_product_items\n\n        for track in tracks:\n            # set track name\n            track.name = f\"{sequence_file_name} - {otio_timeline.name}\"\n\n            try:\n                track_start_frame = (\n                    abs(track.source_range.start_time.value)\n                )\n                track_start_frame -= self.timeline_frame_start\n            except AttributeError:\n                track_start_frame = 0\n\n            for otio_clip in track.find_clips():\n                if not self._validate_clip_for_processing(otio_clip):\n                    continue\n\n                clip_related_content = clip_content.get(otio_clip.name)\n\n                if ignore_clip_no_content:\n                    if not clip_related_content:\n                        continue\n\n                    if not any(\n                        item\n                        for preset in product_type_presets\n                        for item in clip_related_content\n                        if preset[\"product_name\"] in item[\"product_name\"]\n                    ):\n                        self.log.warning(\n                            f\"Clip {otio_clip.name} has no related content.\"\n                            \" Skipping clip.\"\n                        )\n                        continue\n\n                # convert timeline range to source range\n                self._restore_otio_source_range(otio_clip)\n\n                base_instance_data = self._get_base_instance_data(\n                    otio_clip,\n                    instance_data,\n                    track_start_frame,\n                    folder_entity\n                )\n\n                parenting_data = {\n                    \"instance_label\": None,\n                    \"instance_id\": None\n                }\n\n                self._make_shot_product_instance(\n                    otio_clip,\n                    deepcopy(base_instance_data),\n                    parenting_data,\n                )\n\n                abs_clip_folder = os.path.join(\n                    media_folder_path, otio_clip.name).replace(\"\\\\\", \"/\")\n\n                for pres_product_data in product_type_presets:\n                    self._make_product_instance(\n                        pres_product_data,\n                        deepcopy(base_instance_data),\n                        parenting_data,\n                        clip_related_content,\n                        abs_clip_folder,\n                    )\n\n    def _include_files_for_processing(\n        self,\n        product_name,\n        filenames,\n        product_data_base,\n        collecting_items,\n        strict=True,\n    ):\n        \"\"\"Supporting function for getting clip content.\n\n        Args:\n            product_name (str): product name\n            partial_path (str): clip folder path\n            filenames (list): list of files in clip folder to collect\n            product_data_base (dict): product data\n            collecting_items (list): list for collecting product data items\n            strict (Optional[bool]): strict mode for filtering files\n        \"\"\"\n        # compile regex pattern for matching product name\n        pattern_search = re.compile(\n            f\".*({re.escape(product_name)}{VARIANTS_PATTERN})\"\n        )\n        # find intersection between files and sequences\n        differences = find_string_differences(filenames)\n        collections, reminders = clique.assemble(filenames)\n        # iterate all collections and search for pattern in file name head\n        for collection in collections:\n            # check if collection is not empty\n            if not collection:\n                continue\n            # check if pattern in name head is present\n            head = collection.format(\"{head}\")\n            tail = collection.format(\"{tail}\")\n            match = pattern_search.search(head)\n\n            # if pattern is not present in file name head\n            if strict and not match:\n                continue\n\n            # add collected files to list\n            # NOTE: Guess thumbnail file - potential danger.\n            filtered_filenames = [\n                file\n                for file in filenames\n                if file.startswith(head)\n                if file.endswith(tail)\n                if \"thumb\" not in file\n            ]\n            extension = os.path.splitext(filtered_filenames[0])[1]\n            product_data = deepcopy(product_data_base)\n            suffix = differences[head + tail]\n            product_data.update({\n                \"type\": \"collection\" if extension in IMAGE_EXTENSIONS else \"other\",\n                \"suffix\": suffix,\n                \"files\": filtered_filenames,\n            })\n\n            if strict and match:\n                product_data[\"product_name\"] = match.group(1)\n\n            collecting_items.append(product_data)\n\n        for reminder in reminders:\n            # check if pattern in name head is present\n            head, tail = os.path.splitext(reminder)\n            match = pattern_search.search(head)\n\n            # if pattern is not present in file name head\n            if strict and not match:\n                continue\n\n            # add collected files to list\n            filtered_filenames = [\n                file for file in filenames\n                if file.startswith(head)\n                if file.endswith(tail)\n            ]\n            extension = os.path.splitext(filtered_filenames[0])[1]\n            suffix = differences[filtered_filenames[0]]\n\n            if match:\n                # remove product name from suffix\n                suffix = suffix.replace(match[1] or match[0], \"\")\n\n            content_type = \"other\"\n            if (\n                extension in VIDEO_EXTENSIONS\n                or extension in IMAGE_EXTENSIONS\n            ):\n                content_type = \"single\"\n\n            # check if file is thumbnail\n            if \"thumb\" in reminder:\n                content_type = \"thumbnail\"\n\n            product_data = deepcopy(product_data_base)\n            product_data.update({\n                \"type\": content_type,\n                \"suffix\": suffix,\n                \"files\": filtered_filenames,\n            })\n\n            if strict and match:\n                # Extract matched pattern and handle special cases with dots\n                # like name.thumbnail.jpg matches\n                matched_pattern = match[1]\n\n                product_data[\"product_name\"] = matched_pattern\n\n            collecting_items.append(product_data)\n\n    def _restore_otio_source_range(self, otio_clip):\n        \"\"\"Infusing source range.\n\n        Otio clip is missing proper source clip range so\n        here we add them from from parent timeline frame range.\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n        \"\"\"\n        otio_clip.source_range = otio_clip.range_in_parent()\n\n    def _make_product_instance(\n        self,\n        product_preset,\n        base_instance_data,\n        parenting_data,\n        clip_content_items,\n        media_folder_path,\n    ):\n        \"\"\"Creating product instances\n\n        Args:\n            product_preset (dict): product preset data\n            base_instance_data (dict): base instance data\n            parenting_data (dict): parenting data\n            clip_content_items (list[dict]): list of clip content items\n            media_folder_path (str): media folder path\n        \"\"\"\n        pres_product_type = product_preset[\"product_type\"]\n        pres_product_name = product_preset[\"product_name\"]\n        pres_versioning = product_preset[\"versioning_type\"]\n        pres_representations = product_preset[\"representations\"]\n\n        # Dictionary to group files by product name\n        grouped_representations = {}\n\n        # First pass: group matching files by product name and representation\n        for item in clip_content_items:\n            item_type = item[\"type\"]\n            if pres_product_name != item[\"preset_name\"]:\n                continue\n\n            product_name = item[\"product_name\"]\n            if product_name not in grouped_representations:\n                grouped_representations[product_name] = {\n                    \"representations\": []\n                }\n\n            # Check each representation preset against the item\n            for repre_preset in pres_representations:\n                preset_repre_name = repre_preset[\"name\"]\n                pres_repr_content_type = repre_preset[\"content_type\"]\n                pres_repr_tags = deepcopy(repre_preset.get(\"tags\", []))\n                pres_repr_custom_tags = deepcopy(\n                    repre_preset.get(\"custom_tags\", []))\n\n                # Prepare filters\n                extensions_filter = [\n                    (ext if ext.startswith(\".\") else f\".{ext}\").lower()\n                    for ext in repre_preset.get(\"extensions\", [])\n                ]\n                patterns_filter = repre_preset.get(\"patterns\", [])\n\n                # Filter matching files\n                matching_files = []\n                for file in item[\"files\"]:\n                    # Validate content type matches item type mapping\n                    if (\n                        pres_repr_content_type not in CONTENT_TYPE_MAPPING[item_type]  # noqa\n                    ):\n                        continue\n\n                    # Filter by extension\n                    if not any(\n                        str(file).lower().endswith(ext)\n                        for ext in extensions_filter\n                    ):\n                        continue\n\n                    # Filter by pattern\n                    if patterns_filter and not any(\n                        re.match(pattern, file)\n                        for pattern in patterns_filter\n                    ):\n                        continue\n\n                    matching_files.append(file)\n\n                if not matching_files:\n                    continue\n\n                abs_dir_path = os.path.join(\n                    media_folder_path, item[\"clip_dir_subpath\"]\n                ).replace(\"\\\\\", \"/\")\n\n                if item[\"clip_dir_subpath\"] == \"/\":\n                    abs_dir_path = media_folder_path\n\n                # get extension from first file\n                repre_ext = os.path.splitext(\n                    matching_files[0])[1].lstrip(\".\").lower()\n\n                if len(matching_files) == 1:\n                    matching_files = matching_files[0]\n\n                repre_data = {\n                    \"ext\": repre_ext,\n                    \"name\": preset_repre_name,\n                    \"files\": matching_files,\n                    \"content_type\": pres_repr_content_type,\n                    # for reviewable checking in next step\n                    \"repre_preset_name\": preset_repre_name,\n                    \"dir_path\": abs_dir_path,\n                    \"tags\": pres_repr_tags,\n                    \"custom_tags\": pres_repr_custom_tags,\n                }\n                # Add optional output name suffix\n                suffix = item[\"suffix\"]\n                if suffix and \"thumb\" not in suffix:\n                    repre_data[\"outputName\"] = suffix\n                    repre_data[\"name\"] += f\"_{suffix}\"\n                grouped_representations[product_name][\n                    \"representations\"].append(repre_data)\n\n        # Second pass: create instances for each group\n        for product_name, group_data in grouped_representations.items():\n            representations = group_data[\"representations\"]\n            if not representations:\n                continue\n\n            # skip case where only thumbnail is present\n            if (\n                len(representations) == 1\n                and representations[0][\"content_type\"] == \"thumbnail\"\n            ):\n                continue\n\n            # get version from files with use of pattern\n            # and versioning type\n            version = None\n            if pres_versioning == \"from_file\":\n                version = self._extract_version_from_files(representations)\n            elif pres_versioning == \"locked\":\n                version = product_preset[\"locked\"]\n\n            # check if product is reviewable\n            reviewable = False\n            for rep_data in representations:\n                for pres_rep in pres_representations:\n                    if pres_rep[\"name\"] == rep_data[\"repre_preset_name\"]:\n                        if \"review\" in pres_rep[\"tags\"]:\n                            reviewable = True\n                            break\n                if reviewable:\n                    break\n\n            # Get basic instance product data\n            instance_data = deepcopy(base_instance_data)\n            self._set_product_data_to_instance(\n                instance_data,\n                pres_product_type,\n                product_name=product_name,\n            )\n\n            # Add review family and other data\n            instance_data.update({\n                \"parent_instance_id\": parenting_data[\"instance_id\"],\n                \"creator_attributes\": {\n                    \"parent_instance\": parenting_data[\"instance_label\"],\n                    \"add_review_family\": reviewable,\n                },\n                \"version\": version,\n                \"prep_representations\": representations,\n            })\n\n            creator_identifier = f\"editorial_{pres_product_type}_advanced\"\n            editorial_clip_creator = self.create_context.creators[\n                creator_identifier]\n\n            # Create instance in creator context\n            editorial_clip_creator.create(instance_data)\n\n    def _extract_version_from_files(self, representations):\n        \"\"\"Extract version information from files\n\n        Files are searched in in trimmed file repesentation data.\n\n        Args:\n            representations (list[dict]): list of representation data\n\n        Returns:\n            str: Highest version found in files, or None if no version found\n        \"\"\"\n        all_found_versions = []\n        for repre in representations:\n            for file in repre[\"files\"]:\n                match = re.match(VERSION_IN_FILE_PATTERN, file)\n                if match:\n                    all_found_versions.append(int(match.group(1)))\n\n        all_found_versions = set(all_found_versions)\n        if all_found_versions:\n            return max(all_found_versions)\n\n        return None\n\n    def _make_shot_product_instance(\n        self,\n        otio_clip,\n        base_instance_data,\n        parenting_data,\n    ):\n        \"\"\"Making shot product instance from input preset\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n            base_instance_data (dict): instance data\n            parenting_data (dict): shot instance parent data\n\n        Returns:\n            CreatedInstance: creator instance object\n        \"\"\"\n        instance_data = deepcopy(base_instance_data)\n        label = self._set_product_data_to_instance(\n            instance_data,\n            \"shot\",\n            product_name=\"shotMain\",\n        )\n        instance_data[\"otioClip\"] = otio.adapters.write_to_string(otio_clip)\n        c_instance = self.create_context.creators[\"editorial_shot\"].create(\n            instance_data\n        )\n        parenting_data.update(\n            {\n                \"instance_label\": label,\n                \"instance_id\": c_instance.data[\"instance_id\"]\n            }\n        )\n        return c_instance\n\n    def _set_product_data_to_instance(\n        self,\n        instance_data,\n        product_type,\n        variant=None,\n        product_name=None,\n    ):\n        \"\"\"Product name maker\n\n        Args:\n            instance_data (dict): instance data\n            product_type (str): product type\n            variant (Optional[str]): product variant\n                default is \"main\"\n            product_name (Optional[str]): product name\n\n        Returns:\n            str: label string\n        \"\"\"\n        if not variant:\n            if product_name:\n                variant = product_name.split(product_type)[-1].lower()\n            else:\n                variant = \"main\"\n\n        folder_path = instance_data[\"creator_attributes\"][\"folderPath\"]\n\n        # product name\n        product_name = product_name or f\"{product_type}{variant.capitalize()}\"\n        label = f\"{folder_path} {product_name}\"\n\n        instance_data.update(\n            {\n                \"label\": label,\n                \"variant\": variant,\n                \"productType\": product_type,\n                \"productName\": product_name,\n            }\n        )\n\n        return label\n\n    def _get_base_instance_data(\n        self,\n        otio_clip,\n        instance_data,\n        track_start_frame,\n        folder_entity,\n    ):\n        \"\"\"Factoring basic set of instance data.\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n            instance_data (dict): precreate instance data\n            track_start_frame (int): track start frame\n\n        Returns:\n            dict: instance data\n\n        \"\"\"\n        parent_folder_path = folder_entity[\"path\"]\n        parent_folder_name = parent_folder_path.rsplit(\"/\", 1)[-1]\n\n        # get clip instance properties\n        handle_start = instance_data[\"handle_start\"]\n        handle_end = instance_data[\"handle_end\"]\n        timeline_offset = instance_data[\"timeline_offset\"]\n        workfile_start_frame = instance_data[\"workfile_start_frame\"]\n        fps = instance_data[\"fps\"]\n        variant_name = instance_data[\"variant\"]\n\n        # basic unique folder name\n        clip_name = os.path.splitext(otio_clip.name)[0]\n        project_entity = ayon_api.get_project(self.project_name)\n\n        shot_name, shot_metadata = self._shot_metadata_solver.generate_data(\n            clip_name,\n            {\n                \"anatomy_data\": {\n                    \"project\": {\n                        \"name\": self.project_name,\n                        \"code\": project_entity[\"code\"]\n                    },\n                    \"parent\": parent_folder_name,\n                    \"app\": self.host_name\n                },\n                \"selected_folder_entity\": folder_entity,\n                \"project_entity\": project_entity\n            }\n        )\n\n        timing_data = self._get_timing_data(\n            otio_clip,\n            timeline_offset,\n            track_start_frame,\n            workfile_start_frame\n        )\n\n        # create creator attributes\n        creator_attributes = {\n            \"workfile_start_frame\": workfile_start_frame,\n            \"fps\": fps,\n            \"handle_start\": int(handle_start),\n            \"handle_end\": int(handle_end)\n        }\n        # add timing data\n        creator_attributes.update(timing_data)\n\n        # create base instance data\n        base_instance_data = {\n            \"shotName\": shot_name,\n            \"variant\": variant_name,\n            \"task\": None,\n            \"newHierarchyIntegration\": True,\n            \"trackStartFrame\": track_start_frame,\n            \"timelineOffset\": timeline_offset,\n\n            # creator_attributes\n            \"creator_attributes\": creator_attributes\n        }\n        # update base instance data with context data\n        # and also update creator attributes with context data\n        creator_attributes[\"folderPath\"] = shot_metadata.pop(\"folderPath\")\n        base_instance_data[\"folderPath\"] = parent_folder_path\n\n        # add creator attributes to shared instance data\n        base_instance_data[\"creator_attributes\"] = creator_attributes\n        # add hierarchy shot metadata\n        base_instance_data.update(shot_metadata)\n\n        return base_instance_data\n\n    def _get_timing_data(\n        self,\n        otio_clip,\n        timeline_offset,\n        track_start_frame,\n        workfile_start_frame\n    ):\n        \"\"\"Returning available timing data\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n            timeline_offset (int): offset value\n            track_start_frame (int): starting frame input\n            workfile_start_frame (int): start frame for shot's workfiles\n\n        Returns:\n            dict: timing metadata\n        \"\"\"\n        # frame ranges data\n        clip_in = otio_clip.range_in_parent().start_time.value\n        clip_in += track_start_frame\n        clip_out = otio_clip.range_in_parent().end_time_inclusive().value\n        clip_out += track_start_frame\n\n        # add offset in case there is any\n        if timeline_offset:\n            clip_in += timeline_offset\n            clip_out += timeline_offset\n\n        clip_duration = otio_clip.duration().value\n        source_in = otio_clip.trimmed_range().start_time.value\n        source_out = source_in + clip_duration\n\n        # define starting frame for future shot\n        frame_start = (\n            clip_in if workfile_start_frame is None\n            else workfile_start_frame\n        )\n        frame_end = frame_start + (clip_duration - 1)\n\n        return {\n            \"frameStart\": int(frame_start),\n            \"frameEnd\": int(frame_end),\n            \"clipIn\": int(clip_in),\n            \"clipOut\": int(clip_out),\n            \"clipDuration\": int(otio_clip.duration().value),\n            \"sourceIn\": int(source_in),\n            \"sourceOut\": int(source_out)\n        }\n\n    def _get_allowed_product_type_presets(self, pre_create_data):\n        \"\"\"Filter out allowed product type presets.\n\n        Args:\n            pre_create_data (dict): precreate attributes inputs\n\n        Returns:\n            list: Filtered list of extended preset items.\n        \"\"\"\n        return [\n            # return dict with name of preset and add preset dict\n            {\"product_name\": product_name, **preset}\n            for product_name, preset in self.get_product_presets_with_names().items()  # noqa\n            if pre_create_data[product_name]\n        ]\n\n    def _validate_clip_for_processing(self, otio_clip):\n        \"\"\"Validate otio clip attributes\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n\n        Returns:\n            bool: True if all passing conditions\n        \"\"\"\n        if otio_clip.name is None:\n            return False\n\n        if isinstance(otio_clip, otio.schema.Gap):\n            return False\n\n        # skip all generators like black empty\n        if isinstance(\n            otio_clip.media_reference,\n                otio.schema.GeneratorReference):\n            return False\n\n        # Transitions are ignored, because Clips have the full frame\n        # range.\n        if isinstance(otio_clip, otio.schema.Transition):\n            return False\n\n        return True\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Creating pre-create attributes at creator plugin.\n\n        Returns:\n            list: list of attribute object instances\n        \"\"\"\n        # Use same attributes as for instance attrobites\n        attr_defs = [\n            FileDef(\n                \"sequence_filepath_data\",\n                folders=False,\n                extensions=[\".edl\", \".xml\", \".aaf\", \".fcpxml\"],\n                allow_sequences=False,\n                single_item=False,\n                label=\"Sequence file\",\n            ),\n            FileDef(\n                \"folder_path_data\",\n                folders=True,\n                single_item=False,\n                extensions=[],\n                allow_sequences=False,\n                label=\"Folder path\",\n            ),\n            # TODO: perhaps better would be timecode and fps input\n            NumberDef(\"timeline_offset\", default=0, label=\"Timeline offset\"),\n            UISeparatorDef(\"one\"),\n            UILabelDef(\"Clip instance attributes\"),\n            BoolDef(\n                \"ignore_clip_no_content\",\n                label=\"Ignore clips with no content\",\n                default=True\n            ),\n            UILabelDef(\"Products Search\"),\n            UISeparatorDef(\"two\"),\n        ]\n\n        # transform all items in product type presets to join product\n        # type and product variant together as single camel case string\n        product_names = self.get_product_presets_with_names()\n\n        # add variants swithers\n        attr_defs.extend(\n            BoolDef(\n                name,\n                label=name,\n                default=preset[\"default_enabled\"],\n            )\n            for name, preset in product_names.items()\n        )\n        attr_defs.append(UISeparatorDef(\"three\"))\n\n        attr_defs.extend(CREATOR_CLIP_ATTR_DEFS)\n        return attr_defs\n\n    def get_product_presets_with_names(self):\n        \"\"\"Get product type presets names.\n        Returns:\n            dict: dict with product names and preset items\n        \"\"\"\n        output = {}\n        for item in self.product_type_presets:\n            product_name = (\n                f\"{item['product_type']}\"\n                f\"{(item['variant']).capitalize()}\"\n            )\n            output[product_name] = item\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialAdvancedCreator.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Creating pre-create attributes at creator plugin.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of attribute object instances</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Creating pre-create attributes at creator plugin.\n\n    Returns:\n        list: list of attribute object instances\n    \"\"\"\n    # Use same attributes as for instance attrobites\n    attr_defs = [\n        FileDef(\n            \"sequence_filepath_data\",\n            folders=False,\n            extensions=[\".edl\", \".xml\", \".aaf\", \".fcpxml\"],\n            allow_sequences=False,\n            single_item=False,\n            label=\"Sequence file\",\n        ),\n        FileDef(\n            \"folder_path_data\",\n            folders=True,\n            single_item=False,\n            extensions=[],\n            allow_sequences=False,\n            label=\"Folder path\",\n        ),\n        # TODO: perhaps better would be timecode and fps input\n        NumberDef(\"timeline_offset\", default=0, label=\"Timeline offset\"),\n        UISeparatorDef(\"one\"),\n        UILabelDef(\"Clip instance attributes\"),\n        BoolDef(\n            \"ignore_clip_no_content\",\n            label=\"Ignore clips with no content\",\n            default=True\n        ),\n        UILabelDef(\"Products Search\"),\n        UISeparatorDef(\"two\"),\n    ]\n\n    # transform all items in product type presets to join product\n    # type and product variant together as single camel case string\n    product_names = self.get_product_presets_with_names()\n\n    # add variants swithers\n    attr_defs.extend(\n        BoolDef(\n            name,\n            label=name,\n            default=preset[\"default_enabled\"],\n        )\n        for name, preset in product_names.items()\n    )\n    attr_defs.append(UISeparatorDef(\"three\"))\n\n    attr_defs.extend(CREATOR_CLIP_ATTR_DEFS)\n    return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialAdvancedCreator.get_product_presets_with_names","title":"<code>get_product_presets_with_names()</code>","text":"<p>Get product type presets names. Returns:     dict: dict with product names and preset items</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>def get_product_presets_with_names(self):\n    \"\"\"Get product type presets names.\n    Returns:\n        dict: dict with product names and preset items\n    \"\"\"\n    output = {}\n    for item in self.product_type_presets:\n        product_name = (\n            f\"{item['product_type']}\"\n            f\"{(item['variant']).capitalize()}\"\n        )\n        output[product_name] = item\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialAudioInstanceCreator","title":"<code>EditorialAudioInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Audio product type class</p> <p>Audio representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialAudioInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Audio product type class\n\n    Audio representation instance.\n    \"\"\"\n    identifier = \"editorial_audio_advanced\"\n    product_type = \"audio\"\n    label = \"Audio product\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialCameraInstanceCreator","title":"<code>EditorialCameraInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Camera product type class Camera representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialCameraInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Camera product type class\n    Camera representation instance.\n    \"\"\"\n    identifier = \"editorial_camera_advanced\"\n    product_type = \"camera\"\n    label = \"Camera product\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialClipInstanceCreatorBase","title":"<code>EditorialClipInstanceCreatorBase</code>","text":"<p>               Bases: <code>HiddenTrayPublishCreator</code></p> <p>Wrapper class for clip product type creators.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialClipInstanceCreatorBase(HiddenTrayPublishCreator):\n    \"\"\"Wrapper class for clip product type creators.\"\"\"\n    host_name = \"traypublisher\"\n\n    def create(self, instance_data, source_data=None):\n        product_name = instance_data[\"productName\"]\n\n        # Create new instance\n        new_instance = CreatedInstance(\n            self.product_type, product_name, instance_data, self\n        )\n\n        self._store_new_instance(new_instance)\n\n        return new_instance\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\n                \"add_review_family\",\n                default=True,\n                label=\"Review\"\n            ),\n            TextDef(\n                \"parent_instance\",\n                label=\"Linked to\",\n                disabled=True\n            ),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialImageInstanceCreator","title":"<code>EditorialImageInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Image product type class</p> <p>Plate representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialImageInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Image product type class\n\n    Plate representation instance.\n    \"\"\"\n    identifier = \"editorial_image_advanced\"\n    product_type = \"image\"\n    label = \"Image product\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialModelInstanceCreator","title":"<code>EditorialModelInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Model product type class</p> <p>Model representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialModelInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Model product type class\n\n    Model representation instance.\n    \"\"\"\n    identifier = \"editorial_model_advanced\"\n    product_type = \"model\"\n    label = \"Model product\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialPlateInstanceCreator","title":"<code>EditorialPlateInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Plate product type class</p> <p>Plate representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialPlateInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Plate product type class\n\n    Plate representation instance.\n    \"\"\"\n    identifier = \"editorial_plate_advanced\"\n    product_type = \"plate\"\n    label = \"Plate product\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialRenderInstanceCreator","title":"<code>EditorialRenderInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Render product type class Render representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialRenderInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Render product type class\n    Render representation instance.\n    \"\"\"\n    identifier = \"editorial_render_advanced\"\n    product_type = \"render\"\n    label = \"Render product\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialShotInstanceCreator","title":"<code>EditorialShotInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Shot product type class</p> <p>The shot metadata instance carrier.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialShotInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Shot product type class\n\n    The shot metadata instance carrier.\n    \"\"\"\n    identifier = \"editorial_shot_advanced\"\n    product_type = \"shot\"\n    label = \"Editorial Shot\"\n\n    def get_instance_attr_defs(self):\n        instance_attributes = [\n            TextDef(\n                \"folderPath\",\n                label=\"Folder path\",\n                disabled=True,\n            )\n        ]\n        instance_attributes.extend(CREATOR_CLIP_ATTR_DEFS)\n        instance_attributes.extend(CLIP_ATTR_DEFS)\n        return instance_attributes\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.EditorialWorkfileInstanceCreator","title":"<code>EditorialWorkfileInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Workfile product type class</p> <p>Workfile representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>class EditorialWorkfileInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Workfile product type class\n\n    Workfile representation instance.\n    \"\"\"\n    identifier = \"editorial_workfile_advanced\"\n    product_type = \"workfile\"\n    label = \"Workfile product\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_advanced.html#client.ayon_traypublisher.plugins.create.create_editorial_advanced.find_string_differences","title":"<code>find_string_differences(files)</code>","text":"<p>Find common parts and differences between all strings in a list. Returns dictionary with original strings as keys and unique parts as values. The unique parts will: - not include file extensions - be stripped of whitespace - be stripped of dots and underscores from both ends - stripped of sequence numbers and padding</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_advanced.py</code> <pre><code>def find_string_differences(files: List[str]) -&gt; Dict[str, str]:\n    \"\"\"\n    Find common parts and differences between all strings in a list.\n    Returns dictionary with original strings as keys and unique parts as values.\n    The unique parts will:\n    - not include file extensions\n    - be stripped of whitespace\n    - be stripped of dots and underscores from both ends\n    - stripped of sequence numbers and padding\n    \"\"\"\n    if not files:\n        return {}\n\n    # convert first all files to collections and reminders\n    files_collected = []\n    collections, reminders = clique.assemble(files)\n    for collection in collections:\n        head = collection.format(\"{head}\")\n        tail = collection.format(\"{tail}\")\n        files_collected.append(head + tail)\n    for reminder in reminders:\n        files_collected.append(reminder)\n\n    # Remove extensions and convert to list for processing\n    processed_files = [os.path.splitext(f)[0] for f in files_collected]\n\n    # Find common prefix using zip_longest to compare all characters at once\n    prefix = \"\"\n    for chars in zip_longest(*processed_files):\n        if len(set(chars) - {None}) != 1:  # If there's more than one unique character\n            break\n        prefix += chars[0]\n\n    # Find common suffix by reversing strings\n    reversed_files = [f[::-1] for f in processed_files]\n    suffix = \"\"\n    for chars in zip_longest(*reversed_files):\n        if len(set(chars) - {None}) != 1:\n            break\n        suffix = chars[0] + suffix\n\n    # Create result dictionary\n    prefix_len = len(prefix)\n    suffix_len = len(suffix)\n    result = {}\n\n    for original, processed in zip(files_collected, processed_files):\n        # Extract the difference\n        diff = (\n            processed[prefix_len:-suffix_len] if suffix\n            else processed[prefix_len:]\n        )\n        # Clean up the difference\n        # remove version pattern from the diff\n        version_pattern = re.compile(r\".*(v\\d{2,4}).*\")\n        if match := re.match(version_pattern, diff):\n            # version string included v##\n            version_str = match[1]\n            diff = diff.replace(version_str, \"\")\n\n        # Remove whitespace, dots and underscores\n        diff = diff.strip().strip(\"._\")\n\n        result[original] = diff\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_package.html","title":"create_editorial_package","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_package.html#client.ayon_traypublisher.plugins.create.create_editorial_package.EditorialPackageCreator","title":"<code>EditorialPackageCreator</code>","text":"<p>               Bases: <code>TrayPublishCreator</code></p> <p>Creates instance for OTIO file from published folder.</p> <p>Folder contains OTIO file and exported .mov files. Process should publish whole folder as single <code>editorial_pkg</code> product type and (possibly) convert .mov files into different format and copy them into <code>publish</code> <code>resources</code> subfolder.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_package.py</code> <pre><code>class EditorialPackageCreator(TrayPublishCreator):\n    \"\"\"Creates instance for OTIO file from published folder.\n\n    Folder contains OTIO file and exported .mov files. Process should publish\n    whole folder as single `editorial_pkg` product type and (possibly) convert\n    .mov files into different format and copy them into `publish` `resources`\n    subfolder.\n    \"\"\"\n    identifier = \"editorial_pkg\"\n    label = \"Editorial package\"\n    product_type = \"editorial_pkg\"\n    description = \"Publish folder with OTIO file and resources\"\n\n    # Position batch creator after simple creators\n    order = 120\n\n    conversion_enabled = False\n\n    def apply_settings(self, project_settings):\n        self.conversion_enabled = (\n            project_settings[\"traypublisher\"]\n                            [\"publish\"]\n                            [\"ExtractEditorialPckgConversion\"]\n                            [\"conversion_enabled\"]\n        )\n\n    def get_icon(self):\n        return \"fa.folder\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        folder_path = pre_create_data.get(\"folder_path\")\n        if not folder_path:\n            return\n\n        instance_data[\"creator_attributes\"] = {\n            \"folder_path\": (Path(folder_path[\"directory\"]) /\n                            Path(folder_path[\"filenames\"][0])).as_posix(),\n            \"conversion_enabled\": pre_create_data[\"conversion_enabled\"]\n        }\n\n        # Create new instance\n        new_instance = CreatedInstance(self.product_type, product_name,\n                                       instance_data, self)\n        self._store_new_instance(new_instance)\n\n    def get_pre_create_attr_defs(self):\n        # Use same attributes as for instance attributes\n        return [\n            FileDef(\n                \"folder_path\",\n                folders=True,\n                single_item=True,\n                extensions=[],\n                allow_sequences=False,\n                label=\"Folder path\"\n            ),\n            BoolDef(\"conversion_enabled\",\n                    tooltip=\"Convert to output defined in Settings.\",\n                    default=self.conversion_enabled,\n                    label=\"Convert resources\"),\n        ]\n\n    def get_instance_attr_defs(self):\n        return [\n            TextDef(\n                \"folder_path\",\n                label=\"Folder path\",\n                disabled=True\n            ),\n            BoolDef(\"conversion_enabled\",\n                    tooltip=\"Convert to output defined in Settings.\",\n                    label=\"Convert resources\"),\n        ]\n\n    def get_detail_description(self):\n        return \"\"\"# Publish folder with OTIO file and video clips\n\n        Folder contains OTIO file and exported .mov files. Process should\n        publish whole folder as single `editorial_pkg` product type and\n        (possibly) convert .mov files into different format and copy them into\n        `publish` `resources` subfolder.\n        \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_simple.html","title":"create_editorial_simple","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_simple.html#client.ayon_traypublisher.plugins.create.create_editorial_simple.EditorialAudioInstanceCreator","title":"<code>EditorialAudioInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Audio product type class</p> <p>Audio representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_simple.py</code> <pre><code>class EditorialAudioInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Audio product type class\n\n    Audio representation instance.\n    \"\"\"\n    identifier = \"editorial_audio\"\n    product_type = \"audio\"\n    label = \"Editorial Audio\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_simple.html#client.ayon_traypublisher.plugins.create.create_editorial_simple.EditorialClipInstanceCreatorBase","title":"<code>EditorialClipInstanceCreatorBase</code>","text":"<p>               Bases: <code>HiddenTrayPublishCreator</code></p> <p>Wrapper class for clip product type creators.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_simple.py</code> <pre><code>class EditorialClipInstanceCreatorBase(HiddenTrayPublishCreator):\n    \"\"\"Wrapper class for clip product type creators.\"\"\"\n    host_name = \"traypublisher\"\n\n    def create(self, instance_data, source_data=None):\n        product_name = instance_data[\"productName\"]\n\n        # Create new instance\n        new_instance = CreatedInstance(\n            self.product_type, product_name, instance_data, self\n        )\n\n        self._store_new_instance(new_instance)\n\n        return new_instance\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\n                \"add_review_family\",\n                default=True,\n                label=\"Review\"\n            ),\n            TextDef(\n                \"parent_instance\",\n                label=\"Linked to\",\n                disabled=True\n            ),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_simple.html#client.ayon_traypublisher.plugins.create.create_editorial_simple.EditorialPlateInstanceCreator","title":"<code>EditorialPlateInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Plate product type class</p> <p>Plate representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_simple.py</code> <pre><code>class EditorialPlateInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Plate product type class\n\n    Plate representation instance.\n    \"\"\"\n    identifier = \"editorial_plate\"\n    product_type = \"plate\"\n    label = \"Editorial Plate\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_simple.html#client.ayon_traypublisher.plugins.create.create_editorial_simple.EditorialReviewInstanceCreator","title":"<code>EditorialReviewInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Review product type class</p> <p>Review representation instance.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_simple.py</code> <pre><code>class EditorialReviewInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Review product type class\n\n    Review representation instance.\n    \"\"\"\n    identifier = \"editorial_review\"\n    product_type = \"review\"\n    label = \"Editorial Review\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_simple.html#client.ayon_traypublisher.plugins.create.create_editorial_simple.EditorialShotInstanceCreator","title":"<code>EditorialShotInstanceCreator</code>","text":"<p>               Bases: <code>EditorialClipInstanceCreatorBase</code></p> <p>Shot product type class</p> <p>The shot metadata instance carrier.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_simple.py</code> <pre><code>class EditorialShotInstanceCreator(EditorialClipInstanceCreatorBase):\n    \"\"\"Shot product type class\n\n    The shot metadata instance carrier.\n    \"\"\"\n    identifier = \"editorial_shot\"\n    product_type = \"shot\"\n    label = \"Editorial Shot\"\n\n    def get_instance_attr_defs(self):\n        instance_attributes = [\n            TextDef(\n                \"folderPath\",\n                label=\"Folder path\",\n                disabled=True,\n            )\n        ]\n        instance_attributes.extend(CLIP_ATTR_DEFS)\n        return instance_attributes\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_simple.html#client.ayon_traypublisher.plugins.create.create_editorial_simple.EditorialSimpleCreator","title":"<code>EditorialSimpleCreator</code>","text":"<p>               Bases: <code>TrayPublishCreator</code></p> <p>Editorial creator class</p> <p>Simple workflow creator. This creator only disecting input video file into clip chunks and then converts each to defined format defined Settings for each product preset.</p> <p>Parameters:</p> Name Type Description Default <code>TrayPublishCreator</code> <code>Creator</code> <p>Tray publisher plugin class</p> required Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_simple.py</code> <pre><code>class EditorialSimpleCreator(TrayPublishCreator):\n    \"\"\"Editorial creator class\n\n    Simple workflow creator. This creator only disecting input\n    video file into clip chunks and then converts each to\n    defined format defined Settings for each product preset.\n\n    Args:\n        TrayPublishCreator (Creator): Tray publisher plugin class\n    \"\"\"\n    enabled = True\n    label = \"Editorial Simple\"\n    product_type = \"editorial\"\n    identifier = \"editorial_simple\"\n    default_variants = [\n        \"main\"\n    ]\n    description = \"Editorial files to generate shots.\"\n    detailed_description = \"\"\"\nSupporting publishing new shots to project\nor updating already created. Publishing will create OTIO file.\n\"\"\"\n    icon = \"fa.file\"\n    product_type_presets = []\n\n    def __init__(self, *args, **kwargs):\n        self._shot_metadata_solver = ShotMetadataSolver(self.log)\n        super(EditorialSimpleCreator, self).__init__(*args, **kwargs)\n\n    def apply_settings(self, project_settings):\n        editorial_creators = deepcopy(\n            project_settings[\"traypublisher\"][\"editorial_creators\"]\n        )\n        creator_settings = editorial_creators.get(self.identifier)\n\n        self.enabled = creator_settings[\"enabled\"]\n\n        self._shot_metadata_solver.update_data(\n            creator_settings[\"clip_name_tokenizer\"],\n            creator_settings[\"shot_rename\"],\n            creator_settings[\"shot_hierarchy\"],\n            creator_settings[\"shot_add_tasks\"]\n        )\n        self.product_type_presets = creator_settings[\"product_type_presets\"]\n        default_variants = creator_settings.get(\"default_variants\")\n        if default_variants:\n            self.default_variants = default_variants\n\n    def create(self, product_name, instance_data, pre_create_data):\n        allowed_product_type_presets = self._get_allowed_product_type_presets(\n            pre_create_data)\n\n        product_types = {\n            item[\"product_type\"]\n            for item in self.product_type_presets\n        }\n        clip_instance_properties = {\n            k: v\n            for k, v in pre_create_data.items()\n            if k != \"sequence_filepath_data\"\n            if k not in product_types\n        }\n\n        folder_path = instance_data[\"folderPath\"]\n        folder_entity = ayon_api.get_folder_by_path(\n            self.project_name, folder_path\n        )\n\n        if pre_create_data[\"fps\"] == \"from_selection\":\n            # get 'fps' from folder attributes\n            fps = folder_entity[\"attrib\"][\"fps\"]\n        else:\n            fps = float(pre_create_data[\"fps\"])\n\n        instance_data.update({\n            \"fps\": fps\n        })\n\n        # get path of sequence\n        sequence_path_data = pre_create_data[\"sequence_filepath_data\"]\n        media_path_data = pre_create_data[\"media_filepaths_data\"]\n\n        sequence_paths = self._get_path_from_file_data(\n            sequence_path_data, multi=True)\n        media_path = self._get_path_from_file_data(media_path_data)\n\n        first_otio_timeline = None\n        for seq_path in sequence_paths:\n            # get otio timeline\n            otio_timeline = self._create_otio_timeline(\n                seq_path, fps)\n\n            # Create all clip instances\n            clip_instance_properties.update({\n                \"fps\": fps,\n                \"variant\": instance_data[\"variant\"]\n            })\n\n            # create clip instances\n            self._get_clip_instances(\n                folder_entity,\n                otio_timeline,\n                media_path,\n                clip_instance_properties,\n                allowed_product_type_presets,\n                os.path.basename(seq_path),\n                first_otio_timeline,\n            )\n\n            if not first_otio_timeline:\n                # assign otio timeline for multi file to layer\n                first_otio_timeline = otio_timeline\n\n        # create otio editorial instance\n        self._create_otio_instance(\n            product_name,\n            instance_data,\n            seq_path,\n            first_otio_timeline\n        )\n\n    def _create_otio_instance(\n        self,\n        product_name,\n        data,\n        sequence_path,\n        otio_timeline\n    ):\n        \"\"\"Otio instance creating function\n\n        Args:\n            product_name (str): Product name.\n            data (dict): instance data\n            sequence_path (str): path to sequence file\n            otio_timeline (otio.Timeline): otio timeline object\n        \"\"\"\n        # Pass precreate data to creator attributes\n        data.update({\n            \"sequenceFilePath\": sequence_path,\n            \"otioTimeline\": otio.adapters.write_to_string(otio_timeline)\n        })\n        new_instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n        self._store_new_instance(new_instance)\n\n    def _create_otio_timeline(self, sequence_path, fps):\n        \"\"\"Creating otio timeline from sequence path\n\n        Args:\n            sequence_path (str): path to sequence file\n            fps (float): frame per second\n\n        Returns:\n            otio.Timeline: otio timeline object\n        \"\"\"\n        # get editorial sequence file into otio timeline object\n        extension = os.path.splitext(sequence_path)[1]\n\n        kwargs = {}\n        if extension == \".edl\":\n            # EDL has no frame rate embedded so needs explicit\n            # frame rate else 24 is assumed.\n            kwargs[\"rate\"] = fps\n            kwargs[\"ignore_timecode_mismatch\"] = True\n\n        return otio.adapters.read_from_file(sequence_path, **kwargs)\n\n    def _get_path_from_file_data(self, file_path_data, multi=False):\n        \"\"\"Converting creator path data to single path string\n\n        Args:\n            file_path_data (FileDefItem): creator path data inputs\n            multi (bool): switch to multiple files mode\n\n        Raises:\n            FileExistsError: in case nothing had been set\n\n        Returns:\n            str: path string\n        \"\"\"\n        return_path_list = []\n\n        if isinstance(file_path_data, list):\n            return_path_list = [\n                os.path.join(f[\"directory\"], f[\"filenames\"][0])\n                for f in file_path_data\n            ]\n\n        if not return_path_list:\n            raise FileExistsError(\n                f\"File path was not added: {file_path_data}\")\n\n        return return_path_list if multi else return_path_list[0]\n\n    def _get_clip_instances(\n        self,\n        folder_entity,\n        otio_timeline,\n        media_path,\n        instance_data,\n        product_type_presets,\n        sequence_file_name,\n        first_otio_timeline=None\n    ):\n        \"\"\"Helping function for creating clip instance\n\n        Args:\n            folder_entity (dict[str, Any]): Folder entity.\n            otio_timeline (otio.Timeline): otio timeline object\n            media_path (str): media file path string\n            instance_data (dict): clip instance data\n            product_type_presets (list): list of dict settings product presets\n        \"\"\"\n\n        tracks = otio_timeline.video_tracks()\n\n        # media data for audio stream and reference solving\n        media_data = self._get_media_source_metadata(media_path)\n\n        for track in tracks:\n            # set track name\n            track.name = f\"{sequence_file_name} - {otio_timeline.name}\"\n\n            try:\n                track_start_frame = (\n                    abs(track.source_range.start_time.value)\n                )\n                track_start_frame -= self.timeline_frame_start\n            except AttributeError:\n                track_start_frame = 0\n\n            for otio_clip in track.find_clips():\n                if not self._validate_clip_for_processing(otio_clip):\n                    continue\n\n                # get available frames info to clip data\n                self._create_otio_reference(otio_clip, media_path, media_data)\n\n                # convert timeline range to source range\n                self._restore_otio_source_range(otio_clip)\n\n                base_instance_data = self._get_base_instance_data(\n                    otio_clip,\n                    instance_data,\n                    track_start_frame,\n                    folder_entity\n                )\n\n                # passing for trimming\n                base_instance_data[\"editorialSourcePath\"] = media_path\n\n                parenting_data = {\n                    \"instance_label\": None,\n                    \"instance_id\": None\n                }\n\n                for product_type_preset in product_type_presets:\n                    # exclude audio product type if no audio stream\n                    if (\n                        product_type_preset[\"product_type\"] == \"audio\"\n                        and not media_data.get(\"audio\")\n                    ):\n                        continue\n\n                    self._make_product_instance(\n                        otio_clip,\n                        product_type_preset,\n                        deepcopy(base_instance_data),\n                        parenting_data\n                    )\n\n            # add track to first otioTimeline if it is in input args\n            if first_otio_timeline:\n                first_otio_timeline.tracks.append(deepcopy(track))\n\n    def _restore_otio_source_range(self, otio_clip):\n        \"\"\"Infusing source range.\n\n        Otio clip is missing proper source clip range so\n        here we add them from from parent timeline frame range.\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n        \"\"\"\n        otio_clip.source_range = otio_clip.range_in_parent()\n\n    def _create_otio_reference(\n        self,\n        otio_clip,\n        media_path,\n        media_data\n    ):\n        \"\"\"Creating otio reference at otio clip.\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n            media_path (str): media file path string\n            media_data (dict): media metadata\n        \"\"\"\n        start_frame = media_data[\"start_frame\"]\n        frame_duration = media_data[\"duration\"]\n        fps = media_data[\"fps\"]\n\n        available_range = otio.opentime.TimeRange(\n            start_time=otio.opentime.RationalTime(\n                start_frame, fps),\n            duration=otio.opentime.RationalTime(\n                frame_duration, fps)\n        )\n        # in case old OTIO or video file create `ExternalReference`\n        media_reference = otio.schema.ExternalReference(\n            target_url=media_path,\n            available_range=available_range\n        )\n        otio_clip.media_reference = media_reference\n\n    def _get_media_source_metadata(self, path):\n        \"\"\"Get all available metadata from file\n\n        Args:\n            path (str): media file path string\n\n        Raises:\n            AssertionError: ffprobe couldn't read metadata\n\n        Returns:\n            dict: media file metadata\n        \"\"\"\n        return_data = {}\n\n        try:\n            media_data = get_ffprobe_data(\n                path, self.log\n            )\n\n            # get video stream data\n            video_streams = []\n            audio_streams = []\n            for stream in media_data[\"streams\"]:\n                codec_type = stream.get(\"codec_type\")\n                if codec_type == \"audio\":\n                    audio_streams.append(stream)\n\n                elif codec_type == \"video\":\n                    video_streams.append(stream)\n\n            if not video_streams:\n                raise ValueError(\n                    \"Could not find video stream in source file.\"\n                )\n\n            video_stream = video_streams[0]\n            return_data = {\n                \"video\": True,\n                \"start_frame\": 0,\n                \"duration\": int(video_stream[\"nb_frames\"]),\n                \"fps\": float(\n                    convert_ffprobe_fps_value(\n                        video_stream[\"r_frame_rate\"]\n                    )\n                )\n            }\n\n            # get audio  streams data\n            if audio_streams:\n                return_data[\"audio\"] = True\n\n        except Exception as exc:\n            raise AssertionError((\n                \"FFprobe couldn't read information about input file: \"\n                f\"\\\"{path}\\\". Error message: {exc}\"\n            ))\n\n        return return_data\n\n    def _make_product_instance(\n        self,\n        otio_clip,\n        product_type_preset,\n        instance_data,\n        parenting_data\n    ):\n        \"\"\"Making product instance from input preset\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n            product_type_preset (dict): single product type preset\n            instance_data (dict): instance data\n            parenting_data (dict): shot instance parent data\n\n        Returns:\n            CreatedInstance: creator instance object\n        \"\"\"\n        product_type = product_type_preset[\"product_type\"]\n        label = self._make_product_naming(\n            product_type_preset,\n            instance_data\n        )\n        instance_data[\"label\"] = label\n\n        # add file extension filter only if it is not shot product type\n        if product_type == \"shot\":\n            instance_data[\"otioClip\"] = (\n                otio.adapters.write_to_string(otio_clip))\n            c_instance = self.create_context.creators[\n                \"editorial_shot\"].create(\n                    instance_data)\n            parenting_data.update({\n                \"instance_label\": label,\n                \"instance_id\": c_instance.data[\"instance_id\"]\n            })\n        else:\n            # add review family if defined\n            instance_data.update({\n                \"outputFileType\": product_type_preset[\"output_file_type\"],\n                \"parent_instance_id\": parenting_data[\"instance_id\"],\n                \"creator_attributes\": {\n                    \"parent_instance\": parenting_data[\"instance_label\"],\n                    \"add_review_family\": product_type_preset.get(\"review\")\n                }\n            })\n\n            creator_identifier = f\"editorial_{product_type}\"\n            editorial_clip_creator = self.create_context.creators[\n                creator_identifier]\n            c_instance = editorial_clip_creator.create(\n                instance_data)\n\n        return c_instance\n\n    def _make_product_naming(self, product_type_preset, instance_data):\n        \"\"\"Product name maker\n\n        Args:\n            product_type_preset (dict): single preset item\n            instance_data (dict): instance data\n\n        Returns:\n            str: label string\n        \"\"\"\n        folder_path = instance_data[\"creator_attributes\"][\"folderPath\"]\n\n        variant_name = instance_data[\"variant\"]\n        product_type = product_type_preset[\"product_type\"]\n\n        # get variant name from preset or from inheritance\n        _variant_name = product_type_preset.get(\"variant\") or variant_name\n\n        # product name\n        product_name = \"{}{}\".format(\n            product_type, _variant_name.capitalize()\n        )\n        label = \"{} {}\".format(\n            folder_path,\n            product_name\n        )\n\n        instance_data.update({\n            \"label\": label,\n            \"variant\": _variant_name,\n            \"productType\": product_type,\n            \"productName\": product_name,\n        })\n\n        return label\n\n    def _get_base_instance_data(\n        self,\n        otio_clip,\n        instance_data,\n        track_start_frame,\n        folder_entity,\n    ):\n        \"\"\"Factoring basic set of instance data.\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n            instance_data (dict): precreate instance data\n            track_start_frame (int): track start frame\n\n        Returns:\n            dict: instance data\n\n        \"\"\"\n        parent_folder_path = folder_entity[\"path\"]\n        parent_folder_name = parent_folder_path.rsplit(\"/\", 1)[-1]\n\n        # get clip instance properties\n        handle_start = instance_data[\"handle_start\"]\n        handle_end = instance_data[\"handle_end\"]\n        timeline_offset = instance_data[\"timeline_offset\"]\n        workfile_start_frame = instance_data[\"workfile_start_frame\"]\n        fps = instance_data[\"fps\"]\n        variant_name = instance_data[\"variant\"]\n\n        # basic unique folder name\n        clip_name = os.path.splitext(otio_clip.name)[0]\n        project_entity = ayon_api.get_project(self.project_name)\n\n        shot_name, shot_metadata = self._shot_metadata_solver.generate_data(\n            clip_name,\n            {\n                \"anatomy_data\": {\n                    \"project\": {\n                        \"name\": self.project_name,\n                        \"code\": project_entity[\"code\"]\n                    },\n                    \"parent\": parent_folder_name,\n                    \"app\": self.host_name\n                },\n                \"selected_folder_entity\": folder_entity,\n                \"project_entity\": project_entity\n            }\n        )\n\n        timing_data = self._get_timing_data(\n            otio_clip,\n            timeline_offset,\n            track_start_frame,\n            workfile_start_frame\n        )\n\n        # create creator attributes\n        creator_attributes = {\n\n            \"workfile_start_frame\": workfile_start_frame,\n            \"fps\": fps,\n            \"handle_start\": int(handle_start),\n            \"handle_end\": int(handle_end)\n        }\n        # add timing data\n        creator_attributes.update(timing_data)\n\n        # create base instance data\n        base_instance_data = {\n            \"shotName\": shot_name,\n            \"variant\": variant_name,\n            \"task\": None,\n            \"newHierarchyIntegration\": True,\n            # Backwards compatible (Deprecated since 24/06/06)\n            \"newAssetPublishing\": True,\n            \"trackStartFrame\": track_start_frame,\n            \"timelineOffset\": timeline_offset,\n\n            # creator_attributes\n            \"creator_attributes\": creator_attributes\n        }\n        # update base instance data with context data\n        # and also update creator attributes with context data\n        creator_attributes[\"folderPath\"] = shot_metadata.pop(\"folderPath\")\n        base_instance_data[\"folderPath\"] = parent_folder_path\n\n        # add creator attributes to shared instance data\n        base_instance_data[\"creator_attributes\"] = creator_attributes\n        # add hierarchy shot metadata\n        base_instance_data.update(shot_metadata)\n\n        return base_instance_data\n\n    def _get_timing_data(\n        self,\n        otio_clip,\n        timeline_offset,\n        track_start_frame,\n        workfile_start_frame\n    ):\n        \"\"\"Returning available timing data\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n            timeline_offset (int): offset value\n            track_start_frame (int): starting frame input\n            workfile_start_frame (int): start frame for shot's workfiles\n\n        Returns:\n            dict: timing metadata\n        \"\"\"\n        # frame ranges data\n        clip_in = otio_clip.range_in_parent().start_time.value\n        clip_in += track_start_frame\n        clip_out = otio_clip.range_in_parent().end_time_inclusive().value\n        clip_out += track_start_frame\n\n        # add offset in case there is any\n        if timeline_offset:\n            clip_in += timeline_offset\n            clip_out += timeline_offset\n\n        clip_duration = otio_clip.duration().value\n        source_in = otio_clip.trimmed_range().start_time.value\n        source_out = source_in + clip_duration\n\n        # define starting frame for future shot\n        frame_start = (\n            clip_in if workfile_start_frame is None\n            else workfile_start_frame\n        )\n        frame_end = frame_start + (clip_duration - 1)\n\n        return {\n            \"frameStart\": int(frame_start),\n            \"frameEnd\": int(frame_end),\n            \"clipIn\": int(clip_in),\n            \"clipOut\": int(clip_out),\n            \"clipDuration\": int(otio_clip.duration().value),\n            \"sourceIn\": int(source_in),\n            \"sourceOut\": int(source_out)\n        }\n\n    def _get_allowed_product_type_presets(self, pre_create_data):\n        \"\"\"Filter out allowed product type presets.\n\n        Args:\n            pre_create_data (dict): precreate attributes inputs\n\n        Returns:\n            list: lit of dict with preset items\n        \"\"\"\n        return [\n            {\"product_type\": \"shot\"},\n            *[\n                preset\n                for preset in self.product_type_presets\n                if pre_create_data[preset[\"product_type\"]]\n            ]\n        ]\n\n    def _validate_clip_for_processing(self, otio_clip):\n        \"\"\"Validate otio clip attributes\n\n        Args:\n            otio_clip (otio.Clip): otio clip object\n\n        Returns:\n            bool: True if all passing conditions\n        \"\"\"\n        if otio_clip.name is None:\n            return False\n\n        if isinstance(otio_clip, otio.schema.Gap):\n            return False\n\n        # skip all generators like black empty\n        if isinstance(\n            otio_clip.media_reference,\n                otio.schema.GeneratorReference):\n            return False\n\n        # Transitions are ignored, because Clips have the full frame\n        # range.\n        if isinstance(otio_clip, otio.schema.Transition):\n            return False\n\n        return True\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Creating pre-create attributes at creator plugin.\n\n        Returns:\n            list: list of attribute object instances\n        \"\"\"\n        # Use same attributes as for instance attrobites\n        attr_defs = [\n            FileDef(\n                \"sequence_filepath_data\",\n                folders=False,\n                extensions=[\n                    \".edl\",\n                    \".xml\",\n                    \".aaf\",\n                    \".fcpxml\"\n                ],\n                allow_sequences=False,\n                single_item=False,\n                label=\"Edit Decision List\",\n                tooltip=(\n                    \"An Edit Decision List (EDL) is a list of edits that includes reel and timecode data.\\n\"\n                    \"This information shows where each video clip can be found to create the final cut.\\n\"\n                    \"EDL files can be generated using apps like Nuke Studio and Resolve.\"\n                )\n            ),\n            FileDef(\n                \"media_filepaths_data\",\n                folders=False,\n                extensions=[\n                    \".mov\",\n                    \".mp4\",\n                    \".wav\"\n                ],\n                allow_sequences=False,\n                single_item=False,\n                label=\"Media files\",\n            ),\n            # TODO: perhaps better would be timecode and fps input\n            NumberDef(\n                \"timeline_offset\",\n                default=0,\n                label=\"Timeline offset\"\n            ),\n            UISeparatorDef(),\n            UILabelDef(\"Add products for each discovered shot\"),\n            UISeparatorDef()\n        ]\n        # add variants swithers\n        attr_defs.extend(\n            BoolDef(item[\"product_type\"], label=item[\"product_type\"])\n            for item in self.product_type_presets\n        )\n        attr_defs.append(UISeparatorDef())\n\n        attr_defs.extend(CLIP_ATTR_DEFS)\n        return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_editorial_simple.html#client.ayon_traypublisher.plugins.create.create_editorial_simple.EditorialSimpleCreator.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Creating pre-create attributes at creator plugin.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>list of attribute object instances</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_editorial_simple.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Creating pre-create attributes at creator plugin.\n\n    Returns:\n        list: list of attribute object instances\n    \"\"\"\n    # Use same attributes as for instance attrobites\n    attr_defs = [\n        FileDef(\n            \"sequence_filepath_data\",\n            folders=False,\n            extensions=[\n                \".edl\",\n                \".xml\",\n                \".aaf\",\n                \".fcpxml\"\n            ],\n            allow_sequences=False,\n            single_item=False,\n            label=\"Edit Decision List\",\n            tooltip=(\n                \"An Edit Decision List (EDL) is a list of edits that includes reel and timecode data.\\n\"\n                \"This information shows where each video clip can be found to create the final cut.\\n\"\n                \"EDL files can be generated using apps like Nuke Studio and Resolve.\"\n            )\n        ),\n        FileDef(\n            \"media_filepaths_data\",\n            folders=False,\n            extensions=[\n                \".mov\",\n                \".mp4\",\n                \".wav\"\n            ],\n            allow_sequences=False,\n            single_item=False,\n            label=\"Media files\",\n        ),\n        # TODO: perhaps better would be timecode and fps input\n        NumberDef(\n            \"timeline_offset\",\n            default=0,\n            label=\"Timeline offset\"\n        ),\n        UISeparatorDef(),\n        UILabelDef(\"Add products for each discovered shot\"),\n        UISeparatorDef()\n    ]\n    # add variants swithers\n    attr_defs.extend(\n        BoolDef(item[\"product_type\"], label=item[\"product_type\"])\n        for item in self.product_type_presets\n    )\n    attr_defs.append(UISeparatorDef())\n\n    attr_defs.extend(CLIP_ATTR_DEFS)\n    return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_from_settings.html","title":"create_from_settings","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_movie_batch.html","title":"create_movie_batch","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_movie_batch.html#client.ayon_traypublisher.plugins.create.create_movie_batch.BatchMovieCreator","title":"<code>BatchMovieCreator</code>","text":"<p>               Bases: <code>TrayPublishCreator</code></p> <p>Creates instances from movie file(s).</p> <p>Intended for .mov files, but should work for any video file. Doesn't handle image sequences though.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_movie_batch.py</code> <pre><code>class BatchMovieCreator(TrayPublishCreator):\n    \"\"\"Creates instances from movie file(s).\n\n    Intended for .mov files, but should work for any video file.\n    Doesn't handle image sequences though.\n    \"\"\"\n    identifier = \"render_movie_batch\"\n    label = \"Batch Movies\"\n    product_type = \"render\"\n    description = \"Publish batch of video files\"\n\n    create_allow_context_change = False\n    version_regex = re.compile(r\"^(.+)_v([0-9]+)$\")\n    # Position batch creator after simple creators\n    order = 110\n\n    def apply_settings(self, project_settings):\n        creator_settings = (\n            project_settings[\"traypublisher\"][\"create\"][\"BatchMovieCreator\"]\n        )\n        self.default_variants = creator_settings[\"default_variants\"]\n        self.default_tasks = creator_settings[\"default_tasks\"]\n        self.extensions = creator_settings[\"extensions\"]\n\n    def get_icon(self):\n        return \"fa.file\"\n\n    def create(self, product_name, data, pre_create_data):\n        file_paths = pre_create_data.get(\"filepath\")\n        if not file_paths:\n            return\n\n        data_by_folder_id = collections.defaultdict(list)\n        for file_info in file_paths:\n            instance_data = copy.deepcopy(data)\n            file_name = file_info[\"filenames\"][0]\n            filepath = os.path.join(file_info[\"directory\"], file_name)\n            instance_data[\"creator_attributes\"] = {\"filepath\": filepath}\n\n            folder_entity, version = get_folder_entity_from_filename(\n                self.project_name, file_name, self.version_regex)\n            data_by_folder_id[folder_entity[\"id\"]].append(\n                (instance_data, folder_entity)\n            )\n\n        all_task_entities = ayon_api.get_tasks(\n            self.project_name, task_ids=set(data_by_folder_id.keys())\n        )\n        task_entity_by_folder_id = collections.defaultdict(dict)\n        for task_entity in all_task_entities:\n            folder_id = task_entity[\"folderId\"]\n            task_name = task_entity[\"name\"].lower()\n            task_entity_by_folder_id[folder_id][task_name] = task_entity\n\n        for (\n            folder_id, (instance_data, folder_entity)\n        ) in data_by_folder_id.items():\n            task_entities_by_name = task_entity_by_folder_id[folder_id]\n            task_name = None\n            task_entity = None\n            for default_task_name in self.default_tasks:\n                _name = default_task_name.lower()\n                if _name in task_entities_by_name:\n                    task_name = task_entity[\"name\"]\n                    task_entity = task_entities_by_name[_name]\n                    break\n\n            product_name = self._get_product_name(\n                self.project_name, task_entity, data[\"variant\"]\n            )\n\n            instance_data[\"folderPath\"] = folder_entity[\"path\"]\n            instance_data[\"task\"] = task_name\n\n            # Create new instance\n            new_instance = CreatedInstance(self.product_type, product_name,\n                                           instance_data, self)\n            self._store_new_instance(new_instance)\n\n    def _get_product_name(self, project_name, task_entity, variant):\n        \"\"\"Create product name according to standard template process\"\"\"\n        host_name = self.create_context.host_name\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n        try:\n            product_name = get_product_name(\n                project_name,\n                task_name,\n                task_type,\n                host_name,\n                self.product_type,\n                variant,\n            )\n        except TaskNotSetError:\n            # Create instance with fake task\n            # - instance will be marked as invalid so it can't be published\n            #   but user have ability to change it\n            # NOTE: This expect that there is not task 'Undefined' on folder\n            dumb_value = \"Undefined\"\n            product_name = get_product_name(\n                project_name,\n                dumb_value,\n                dumb_value,\n                host_name,\n                self.product_type,\n                variant,\n            )\n\n        return product_name\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\n                \"add_review_family\",\n                default=True,\n                label=\"Review\"\n            )\n        ]\n\n    def get_pre_create_attr_defs(self):\n        # Use same attributes as for instance attributes\n        return [\n            FileDef(\n                \"filepath\",\n                folders=False,\n                single_item=False,\n                extensions=self.extensions,\n                allow_sequences=False,\n                label=\"Filepath\"\n            ),\n            BoolDef(\n                \"add_review_family\",\n                default=True,\n                label=\"Review\"\n            )\n        ]\n\n    def get_detail_description(self):\n        return \"\"\"# Publish batch of .mov to multiple folders.\n\n        File names must then contain only folder name, or folder name + version.\n        (eg. 'chair.mov', 'chair_v001.mov', not really safe `my_chair_v001.mov`\n        \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_online.html","title":"create_online","text":"<p>Creator of online files.</p> <p>Online file retain their original name and use it as product name. To avoid conflicts, this creator checks if product with this name already exists under selected folder.</p>"},{"location":"autoapi/client/ayon_traypublisher/plugins/create/create_online.html#client.ayon_traypublisher.plugins.create.create_online.OnlineCreator","title":"<code>OnlineCreator</code>","text":"<p>               Bases: <code>TrayPublishCreator</code></p> <p>Creates instance from file and retains its original name.</p> Source code in <code>client/ayon_traypublisher/plugins/create/create_online.py</code> <pre><code>class OnlineCreator(TrayPublishCreator):\n    \"\"\"Creates instance from file and retains its original name.\"\"\"\n\n    identifier = \"io.ayon.creators.traypublisher.online\"\n    label = \"Online\"\n    product_type = \"online\"\n    description = \"Publish file retaining its original file name\"\n    extensions = [\".mov\", \".mp4\", \".mxf\", \".m4v\", \".mpg\", \".exr\",\n                  \".dpx\", \".tif\", \".png\", \".jpg\"]\n\n    def get_detail_description(self):\n        return \"\"\"# Create file retaining its original file name.\n\n        This will publish files using template helping to retain original\n        file name and that file name is used as product name.\n\n        Bz default it tries to guard against multiple publishes of the same\n        file.\"\"\"\n\n    def get_icon(self):\n        return \"fa.file\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        repr_file = pre_create_data.get(\"representation_file\")\n        if not repr_file:\n            raise CreatorError(\"No files specified\")\n\n        files = repr_file.get(\"filenames\")\n        if not files:\n            # this should never happen\n            raise CreatorError(\"Missing files from representation\")\n\n        origin_basename = Path(files[0]).stem\n\n        # disable check for existing product with the same name\n        \"\"\"\n        folder_entity = ayon_api.get_folder_by_path(\n            self.project_name, instance_data[\"folderPath\"], fields={\"id\"})\n\n        if ayon_api.get_product_by_name(\n                self.project_name, origin_basename, folder_entity[\"id\"],\n                fields={\"id\"}):\n            raise CreatorError(f\"product with {origin_basename} already \"\n                               \"exists in selected folder\")\n        \"\"\"\n\n        instance_data[\"originalBasename\"] = origin_basename\n        product_name = origin_basename\n\n        instance_data[\"creator_attributes\"] = {\n            \"path\": (Path(repr_file[\"directory\"]) / files[0]).as_posix()\n        }\n\n        # Create new instance\n        new_instance = CreatedInstance(self.product_type, product_name,\n                                       instance_data, self)\n        self._store_new_instance(new_instance)\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\n                \"add_review_family\",\n                default=True,\n                label=\"Review\"\n            )\n        ]\n\n    def get_pre_create_attr_defs(self):\n        return [\n            FileDef(\n                \"representation_file\",\n                folders=False,\n                extensions=self.extensions,\n                allow_sequences=True,\n                single_item=True,\n                label=\"Representation\",\n            ),\n            BoolDef(\n                \"add_review_family\",\n                default=True,\n                label=\"Review\"\n            )\n        ]\n\n    def get_product_name(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name=None,\n        instance=None\n    ):\n        if instance is None:\n            return \"{originalBasename}\"\n\n        return instance.data[\"productName\"]\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_app_name.html","title":"collect_app_name","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_app_name.html#client.ayon_traypublisher.plugins.publish.collect_app_name.CollectTrayPublisherAppName","title":"<code>CollectTrayPublisherAppName</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect app name and label.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_app_name.py</code> <pre><code>class CollectTrayPublisherAppName(pyblish.api.ContextPlugin):\n    \"\"\"Collect app name and label.\"\"\"\n\n    label = \"Collect App Name/Label\"\n    order = pyblish.api.CollectorOrder - 0.5\n    hosts = [\"traypublisher\"]\n\n    def process(self, context):\n        context.data[\"appName\"] = \"tray publisher\"\n        context.data[\"appLabel\"] = \"Tray publisher\"\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_clip_instances.html","title":"collect_clip_instances","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_clip_instances.html#client.ayon_traypublisher.plugins.publish.collect_clip_instances.CollectClipInstance","title":"<code>CollectClipInstance</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect clip instances and resolve its parent</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_clip_instances.py</code> <pre><code>class CollectClipInstance(pyblish.api.InstancePlugin):\n    \"\"\"Collect clip instances and resolve its parent\"\"\"\n\n    label = \"Collect Clip Instances\"\n    order = pyblish.api.CollectorOrder - 0.081\n\n    hosts = [\"traypublisher\"]\n    families = [\n        \"plate\",\n        \"review\",\n        \"audio\",\n        \"model\",\n        \"camera\",\n        \"render\",\n        \"image\",\n        \"workfile\",\n    ]\n\n    def process(self, instance):\n        creator_identifier = instance.data[\"creator_identifier\"]\n        if creator_identifier not in [\n            \"editorial_plate\",\n            \"editorial_plate_advanced\",\n            \"editorial_audio\",\n            \"editorial_audio_advanced\",\n            \"editorial_review\",\n            \"editorial_model_advanced\",\n            \"editorial_camera_advanced\",\n            \"editorial_render_advanced\",\n            \"editorial_image_advanced\",\n            \"editorial_workfile_advanced\",\n        ]:\n            return\n\n        instance.data[\"families\"].append(\"clip\")\n\n        parent_instance_id = instance.data[\"parent_instance_id\"]\n        edit_shared_data = instance.context.data[\"editorialSharedData\"]\n        instance.data.update(\n            edit_shared_data[parent_instance_id]\n        )\n\n        if \"editorialSourcePath\" in instance.data.keys():\n            instance.data[\"families\"].append(\"trimming\")\n\n        repres = instance.data.pop(\"prep_representations\", None)\n\n        if not repres:\n            return\n\n        representations = []\n        for repre in repres:\n            tags = repre.get(\"tags\", [])\n            custom_tags = repre.get(\"custom_tags\", [])\n            content_type = repre[\"content_type\"]\n\n            if content_type == \"thumbnail\":\n                tags.append(\"thumbnail\")\n\n            # single file type should be a string\n            new_repre_files = repre[\"files\"]\n            if len(new_repre_files) == 1:\n                new_repre_files = new_repre_files[0]\n\n            # create new representation data\n            new_repre_data = {\n                \"ext\": repre[\"ext\"],\n                \"name\": repre[\"name\"],\n                \"files\": new_repre_files,\n                \"stagingDir\": repre[\"dir_path\"],\n                \"tags\": tags,\n                \"custom_tags\": custom_tags,\n            }\n\n            # add optional keys\n            if \"outputName\" in repre.keys():\n                new_repre_data[\"outputName\"] = repre[\"outputName\"]\n\n            representations.append(new_repre_data)\n\n        instance.data[\"representations\"] = representations\n\n        self.log.debug(pformat(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_colorspace_look.html","title":"collect_colorspace_look","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_colorspace_look.html#client.ayon_traypublisher.plugins.publish.collect_colorspace_look.CollectColorspaceLook","title":"<code>CollectColorspaceLook</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Collect OCIO colorspace look from LUT file</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_colorspace_look.py</code> <pre><code>class CollectColorspaceLook(pyblish.api.InstancePlugin,\n                            publish.AYONPyblishPluginMixin):\n    \"\"\"Collect OCIO colorspace look from LUT file\n    \"\"\"\n\n    label = \"Collect Colorspace Look\"\n    order = pyblish.api.CollectorOrder\n    hosts = [\"traypublisher\"]\n    families = [\"ociolook\"]\n\n    def process(self, instance):\n        creator_attrs = instance.data[\"creator_attributes\"]\n\n        # Get config items\n        config_items = instance.data[\"transientData\"][\"config_items\"]\n        config_data = instance.data[\"transientData\"][\"config_data\"]\n\n        # Get global working colorspace\n        if creator_attrs[\"working_colorspace\"]:\n            color_data = colorspace.convert_colorspace_enumerator_item(\n                creator_attrs[\"working_colorspace\"],\n                config_items\n            )\n            working_colorspace = color_data\n            config_data[\"colorspace\"] = working_colorspace[\"name\"]\n        else:\n            working_colorspace = None\n\n        # Collect all LUT files\n        all_files_url = {\n            key: value\n            for key, value in creator_attrs.items()\n            if key.startswith(LUT_KEY_PREFIX)\n        }\n\n        # Create a representation per file.\n        representations = []\n        ocio_look_items = []\n\n        for key, file_url in all_files_url.items():\n\n            file_idx = key.replace(\n                LUT_KEY_PREFIX,\n                \"\"\n            )\n            file_name = os.path.basename(file_url)\n            base_name, ext = os.path.splitext(file_name)\n\n            # set output name with base_name which was cleared\n            # of all symbols and all parts were capitalized\n            output_name = (base_name.replace(\"_\", \" \")\n                                    .replace(\".\", \" \")\n                                    .replace(\"-\", \" \")\n                                    .title()\n                                    .replace(\" \", \"\"))\n\n            # Get LUT colorspace items\n            converted_color_data = {}\n            for colorspace_key in (\n                f\"input_colorspace{file_idx}\",\n                f\"output_colorspace{file_idx}\"\n            ):\n                if creator_attrs[colorspace_key]:\n                    color_data = colorspace.convert_colorspace_enumerator_item(\n                        creator_attrs[colorspace_key], config_items)\n                    converted_color_data[colorspace_key] = color_data\n                else:\n                    converted_color_data[colorspace_key] = None\n\n            # create lut representation data\n            lut_repre_name = f\"LUTfile{file_idx}\"\n            lut_repre = {\n                \"name\": lut_repre_name,\n                \"output\": output_name,\n\n                # When integrating multiple LUT files\n                # with a common extension, there will\n                # be a duplication clash when integrating.\n                # Enforce the outputName to prevent this.\n                \"outputName\": lut_repre_name,\n                \"ext\": ext.lstrip(\".\"),\n                \"files\": file_name,\n                \"stagingDir\": os.path.dirname(file_url),\n                \"tags\": []\n            }\n            representations.append(lut_repre)\n            ocio_look_items.append(\n                {\n                    \"name\": lut_repre_name,\n                    \"ext\": ext.lstrip(\".\"),\n                    \"lut_suffix\": lut_repre_name,\n                    \"input_colorspace\": converted_color_data[\n                        f\"input_colorspace{file_idx}\"],\n                    \"output_colorspace\": converted_color_data[\n                        f\"output_colorspace{file_idx}\"],\n                    \"direction\": creator_attrs[f\"direction{file_idx}\"],\n                    \"interpolation\": creator_attrs[f\"interpolation{file_idx}\"],\n                    \"config_data\": config_data\n                }\n            )\n\n        instance.data.update({\n            \"representations\": representations,\n            \"ocioLookWorkingSpace\": working_colorspace,\n            \"ocioLookItems\": ocio_look_items\n        })\n\n        self.log.debug(pformat(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_csv_ingest_instance_data.html","title":"collect_csv_ingest_instance_data","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_csv_ingest_instance_data.html#client.ayon_traypublisher.plugins.publish.collect_csv_ingest_instance_data.CollectCSVIngestInstancesData","title":"<code>CollectCSVIngestInstancesData</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Collect CSV Ingest data from instance.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_csv_ingest_instance_data.py</code> <pre><code>class CollectCSVIngestInstancesData(\n    pyblish.api.InstancePlugin,\n    publish.AYONPyblishPluginMixin,\n    publish.ColormanagedPyblishPluginMixin\n):\n    \"\"\"Collect CSV Ingest data from instance.\n    \"\"\"\n\n    label = \"Collect CSV Ingest instances data\"\n    order = pyblish.api.CollectorOrder + 0.1\n    hosts = [\"traypublisher\"]\n    families = [\"csv_ingest\"]\n\n    def process(self, instance):\n\n        # expecting [(colorspace, repre_data), ...]\n        prepared_repres_data_items = instance.data[\n            \"prepared_data_for_repres\"]\n\n        for prep_repre_data in prepared_repres_data_items:\n            type = prep_repre_data[\"type\"]\n            colorspace = prep_repre_data[\"colorspace\"]\n            repre_data = prep_repre_data[\"representation\"]\n\n            # thumbnails should be skipped\n            if type == \"media\":\n                # colorspace name is passed from CSV column\n                self.set_representation_colorspace(\n                    repre_data, instance.context, colorspace\n                )\n            elif type == \"media\" and colorspace is None:\n                # TODO: implement colorspace file rules file parsing\n                self.log.warning(\n                    \"Colorspace is not defined in csv for following\"\n                    f\" representation: {pformat(repre_data)}\"\n                )\n                pass\n            elif type == \"thumbnail\":\n                # thumbnails should be skipped\n                pass\n\n            instance.data[\"representations\"].append(repre_data)\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_editorial_instances.html","title":"collect_editorial_instances","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_editorial_instances.html#client.ayon_traypublisher.plugins.publish.collect_editorial_instances.CollectEditorialInstance","title":"<code>CollectEditorialInstance</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect data for instances created by settings creators.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_editorial_instances.py</code> <pre><code>class CollectEditorialInstance(pyblish.api.InstancePlugin):\n    \"\"\"Collect data for instances created by settings creators.\"\"\"\n\n    label = \"Collect Editorial Instances\"\n    order = pyblish.api.CollectorOrder - 0.1\n\n    hosts = [\"traypublisher\"]\n    families = [\"editorial\"]\n\n    def process(self, instance):\n\n        if \"families\" not in instance.data:\n            instance.data[\"families\"] = []\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        fpath = instance.data[\"sequenceFilePath\"]\n        otio_timeline_string = instance.data.pop(\"otioTimeline\")\n        otio_timeline = otio.adapters.read_from_string(\n            otio_timeline_string)\n\n        instance.context.data[\"otioTimeline\"] = otio_timeline\n\n        self.log.info(fpath)\n\n        instance.data[\"stagingDir\"] = os.path.dirname(fpath)\n\n        _, ext = os.path.splitext(fpath)\n\n        instance.data[\"representations\"].append({\n            \"ext\": ext[1:],\n            \"name\": ext[1:],\n            \"stagingDir\": instance.data[\"stagingDir\"],\n            \"files\": os.path.basename(fpath)\n        })\n\n        self.log.debug(\"Created Editorial Instance {}\".format(\n            pformat(instance.data)\n        ))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_editorial_package.html","title":"collect_editorial_package","text":"<p>Produces instance.data[\"editorial_pkg\"] data used during integration.</p> Requires <p>instance.data[\"creator_attributes\"][\"path\"] - from creator</p> Provides <p>instance -&gt; editorial_pkg (dict):                 folder_path (str)                 otio_path   (str) - from dragged folder                 resource_paths (list)</p>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_editorial_package.html#client.ayon_traypublisher.plugins.publish.collect_editorial_package.CollectEditorialPackage","title":"<code>CollectEditorialPackage</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collects path to OTIO file and resources</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_editorial_package.py</code> <pre><code>class CollectEditorialPackage(pyblish.api.InstancePlugin):\n    \"\"\"Collects path to OTIO file and resources\"\"\"\n\n    label = \"Collect Editorial Package\"\n    order = pyblish.api.CollectorOrder - 0.1\n\n    hosts = [\"traypublisher\"]\n    families = [\"editorial_pkg\"]\n\n    def process(self, instance):\n        folder_path = instance.data[\"creator_attributes\"][\"folder_path\"]\n        if not folder_path or not os.path.exists(folder_path):\n            self.log.info((\n                \"Instance doesn't contain collected existing folder path.\"\n            ))\n            return\n\n        instance.data[\"editorial_pkg\"] = {}\n        instance.data[\"editorial_pkg\"][\"folder_path\"] = folder_path\n\n        otio_path, resource_paths = (\n            self._get_otio_and_resource_paths(folder_path))\n\n        instance.data[\"editorial_pkg\"][\"otio_path\"] = otio_path\n        instance.data[\"editorial_pkg\"][\"resource_paths\"] = resource_paths\n\n    def _get_otio_and_resource_paths(self, folder_path):\n        otio_path = None\n        resource_paths = []\n\n        file_names = os.listdir(folder_path)\n        for filename in file_names:\n            _, ext = os.path.splitext(filename)\n            file_path = os.path.join(folder_path, filename)\n            if ext == \".otio\":\n                otio_path = file_path\n            elif ext in VIDEO_EXTENSIONS:\n                resource_paths.append(file_path)\n        return otio_path, resource_paths\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_editorial_reviewable.html","title":"collect_editorial_reviewable","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_editorial_reviewable.html#client.ayon_traypublisher.plugins.publish.collect_editorial_reviewable.CollectEditorialReviewable","title":"<code>CollectEditorialReviewable</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect review input from user.</p> <p>Adds the input to instance data.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_editorial_reviewable.py</code> <pre><code>class CollectEditorialReviewable(pyblish.api.InstancePlugin):\n    \"\"\" Collect review input from user.\n\n    Adds the input to instance data.\n    \"\"\"\n\n    label = \"Collect Editorial Reviewable\"\n    order = pyblish.api.CollectorOrder\n\n    families = [\"plate\", \"review\", \"audio\"]\n    hosts = [\"traypublisher\"]\n\n    def process(self, instance):\n        creator_identifier = instance.data[\"creator_identifier\"]\n        if creator_identifier not in [\n            \"editorial_plate\",\n            \"editorial_audio\",\n            \"editorial_review\"\n        ]:\n            return\n\n        creator_attributes = instance.data[\"creator_attributes\"]\n\n        if creator_attributes[\"add_review_family\"]:\n            instance.data[\"families\"].append(\"review\")\n\n        self.log.debug(\"instance.data {}\".format(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_explicit_colorspace.html","title":"collect_explicit_colorspace","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_explicit_colorspace.html#client.ayon_traypublisher.plugins.publish.collect_explicit_colorspace.CollectColorspace","title":"<code>CollectColorspace</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Collect explicit user defined representation colorspaces</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_explicit_colorspace.py</code> <pre><code>class CollectColorspace(\n    pyblish.api.InstancePlugin,\n    publish.AYONPyblishPluginMixin,\n    publish.ColormanagedPyblishPluginMixin\n):\n    \"\"\"Collect explicit user defined representation colorspaces\"\"\"\n\n    label = \"Choose representation colorspace\"\n    order = pyblish.api.CollectorOrder + 0.49\n    hosts = [\"traypublisher\"]\n    families = [\"render\", \"plate\", \"reference\", \"image\", \"online\"]\n    enabled = False\n\n    default_colorspace_items = [\n        (None, \"Don't override\")\n    ]\n    colorspace_items = list(default_colorspace_items)\n    colorspace_attr_show = False\n    config_items = None\n\n    def process(self, instance):\n        values = self.get_attr_values_from_data(instance.data)\n        colorspace_value = values.get(\"colorspace\", None)\n        if colorspace_value is None:\n            return\n\n        color_data = colorspace.convert_colorspace_enumerator_item(\n            colorspace_value, self.config_items)\n\n        colorspace_name = self._colorspace_name_by_type(color_data)\n        self.log.debug(\"Explicit colorspace name: {}\".format(colorspace_name))\n\n        context = instance.context\n        for repre in instance.data.get(\"representations\", []):\n            self.set_representation_colorspace(\n                representation=repre,\n                context=context,\n                colorspace=colorspace_name\n            )\n\n    def _colorspace_name_by_type(self, colorspace_data):\n        \"\"\"\n        Returns colorspace name by type\n\n        Arguments:\n            colorspace_data (dict): colorspace data\n\n        Returns:\n            str: colorspace name\n\n        \"\"\"\n        type_name = colorspace_data[\"type\"]\n        if type_name == \"colorspaces\":\n            return colorspace_data[\"name\"]\n\n        if type_name == \"roles\":\n            return colorspace_data[\"colorspace\"]\n\n        raise PublishError(\n            \"Collecting of colorspace failed. used config is missing\"\n            f\" colorspace type: '{type_name}'.\"\n            f\" Please contact your pipeline TD.\"\n        )\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        config_data = colorspace.get_current_context_imageio_config_preset(\n            project_settings=project_settings\n        )\n\n        enabled = False\n        colorspace_items = list(cls.default_colorspace_items)\n        config_items = None\n        if config_data:\n            enabled = True\n            filepath = config_data[\"path\"]\n            config_items = colorspace.get_ocio_config_colorspaces(filepath)\n            labeled_colorspaces = colorspace.get_colorspaces_enumerator_items(\n                config_items,\n                include_aliases=True,\n                include_roles=True\n            )\n            colorspace_items.extend(labeled_colorspaces)\n\n        cls.config_items = config_items\n        cls.colorspace_items = colorspace_items\n        cls.enabled = enabled\n\n    @classmethod\n    def get_attribute_defs(cls):\n        return [\n            EnumDef(\n                \"colorspace\",\n                cls.colorspace_items,\n                default=\"Don't override\",\n                label=\"Override Colorspace\"\n            )\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_frame_data_from_folder_entity.html","title":"collect_frame_data_from_folder_entity","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_frame_data_from_folder_entity.html#client.ayon_traypublisher.plugins.publish.collect_frame_data_from_folder_entity.CollectFrameDataFromAssetEntity","title":"<code>CollectFrameDataFromAssetEntity</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Frame Data From <code>taskEntity</code> or <code>folderEntity</code> of instance.</p> <p>Frame range data will only be collected if the keys are not yet collected for the instance.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_frame_data_from_folder_entity.py</code> <pre><code>class CollectFrameDataFromAssetEntity(pyblish.api.InstancePlugin):\n    \"\"\"Collect Frame Data From `taskEntity` or `folderEntity` of instance.\n\n    Frame range data will only be collected if the keys are not yet\n    collected for the instance.\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.491\n    label = \"Collect Missing Frame Data From Folder/Task\"\n    families = [\n        \"plate\",\n        \"pointcache\",\n        \"vdbcache\",\n        \"online\",\n        \"render\",\n    ]\n    hosts = [\"traypublisher\"]\n\n    def process(self, instance):\n        missing_keys = []\n        for key in (\n            \"fps\",\n            \"frameStart\",\n            \"frameEnd\",\n            \"handleStart\",\n            \"handleEnd\",\n        ):\n            if key not in instance.data:\n                missing_keys.append(key)\n\n        # Skip the logic if all keys are already collected.\n        # NOTE: In editorial is not 'folderEntity' filled, so it would crash\n        #   even if we don't need it.\n        if not missing_keys:\n            return\n\n        keys_set = []\n\n        folder_entity = instance.data[\"folderEntity\"]\n        task_entity = instance.data.get(\"taskEntity\")\n        context_attributes = (\n            task_entity[\"attrib\"] if task_entity else folder_entity[\"attrib\"]\n        )\n\n        for key in missing_keys:\n            if key in context_attributes:\n                instance.data[key] = context_attributes[key]\n                keys_set.append(key)\n\n        if keys_set:\n            self.log.debug(\n                f\"Frame range data {keys_set} \"\n                \"has been collected from folder (or task) entity.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_movie_batch.html","title":"collect_movie_batch","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_movie_batch.html#client.ayon_traypublisher.plugins.publish.collect_movie_batch.CollectMovieBatch","title":"<code>CollectMovieBatch</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Collect file url for batch movies and create representation.</p> <p>Adds review on instance and to repre.tags based on value of toggle button on creator.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_movie_batch.py</code> <pre><code>class CollectMovieBatch(\n    pyblish.api.InstancePlugin, AYONPyblishPluginMixin\n):\n    \"\"\"Collect file url for batch movies and create representation.\n\n    Adds review on instance and to repre.tags based on value of toggle button\n    on creator.\n    \"\"\"\n\n    label = \"Collect Movie Batch Files\"\n    order = pyblish.api.CollectorOrder\n\n    hosts = [\"traypublisher\"]\n\n    def process(self, instance):\n        if instance.data.get(\"creator_identifier\") != \"render_movie_batch\":\n            return\n\n        creator_attributes = instance.data[\"creator_attributes\"]\n\n        file_url = creator_attributes[\"filepath\"]\n        file_name = os.path.basename(file_url)\n        _, ext = os.path.splitext(file_name)\n\n        repre = {\n            \"name\": ext[1:],\n            \"ext\": ext[1:],\n            \"files\": file_name,\n            \"stagingDir\": os.path.dirname(file_url),\n            \"tags\": []\n        }\n        instance.data[\"representations\"].append(repre)\n\n        if creator_attributes[\"add_review_family\"]:\n            repre[\"tags\"].append(\"review\")\n            instance.data[\"families\"].append(\"review\")\n            if not instance.data.get(\"thumbnailSource\"):\n                instance.data[\"thumbnailSource\"] = file_url\n\n        instance.data[\"source\"] = file_url\n\n        self.log.debug(\"instance.data {}\".format(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_online_file.html","title":"collect_online_file","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_online_file.html#client.ayon_traypublisher.plugins.publish.collect_online_file.CollectOnlineFile","title":"<code>CollectOnlineFile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect online file and retain its file name.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_online_file.py</code> <pre><code>class CollectOnlineFile(pyblish.api.InstancePlugin):\n    \"\"\"Collect online file and retain its file name.\"\"\"\n    label = \"Collect Online File\"\n    order = pyblish.api.CollectorOrder\n    families = [\"online\"]\n    hosts = [\"traypublisher\"]\n\n    def process(self, instance):\n        file = Path(instance.data[\"creator_attributes\"][\"path\"])\n        review = instance.data[\"creator_attributes\"][\"add_review_family\"]\n        instance.data[\"review\"] = review\n        if \"review\" not in instance.data[\"families\"]:\n            instance.data[\"families\"].append(\"review\")\n        self.log.info(f\"Adding review: {review}\")\n\n        instance.data[\"representations\"].append(\n            {\n                \"name\": file.suffix.lstrip(\".\"),\n                \"ext\": file.suffix.lstrip(\".\"),\n                \"files\": file.name,\n                \"stagingDir\": file.parent.as_posix(),\n                \"tags\": [\"review\"] if review else []\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_review_frames.html","title":"collect_review_frames","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_review_frames.html#client.ayon_traypublisher.plugins.publish.collect_review_frames.CollectReviewInfo","title":"<code>CollectReviewInfo</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect data required for review instances.</p> <p>ExtractReview plugin requires frame start/end, fps on instance data which are missing on instances from TrayPublishes.</p> Warning <p>This is temporary solution to \"make it work\". Contains removed changes     from https://github.com/ynput/OpenPype/pull/4383 reduced only for     review instances.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_review_frames.py</code> <pre><code>class CollectReviewInfo(pyblish.api.InstancePlugin):\n    \"\"\"Collect data required for review instances.\n\n    ExtractReview plugin requires frame start/end, fps on instance data which\n    are missing on instances from TrayPublishes.\n\n    Warning:\n        This is temporary solution to \"make it work\". Contains removed changes\n            from https://github.com/ynput/OpenPype/pull/4383 reduced only for\n            review instances.\n    \"\"\"\n\n    label = \"Collect Review Info\"\n    order = pyblish.api.CollectorOrder + 0.491\n    families = [\"review\"]\n    hosts = [\"traypublisher\"]\n\n    def process(self, instance):\n\n        entity = (\n            instance.data.get(\"taskEntity\")\n            or instance.data.get(\"folderEntity\")\n        )\n        if instance.data.get(\"frameStart\") is not None or not entity:\n            self.log.debug(\"Missing required data on instance\")\n            return\n\n        context_attributes = entity[\"attrib\"]\n        # Store collected data for logging\n        collected_data = {}\n        for key in (\n            \"fps\",\n            \"frameStart\",\n            \"frameEnd\",\n            \"handleStart\",\n            \"handleEnd\",\n        ):\n            if key in instance.data or key not in context_attributes:\n                continue\n            value = context_attributes[key]\n            collected_data[key] = value\n            instance.data[key] = value\n        self.log.debug(\"Collected data: {}\".format(str(collected_data)))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_sequence_frame_data.html","title":"collect_sequence_frame_data","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_sequence_frame_data.html#client.ayon_traypublisher.plugins.publish.collect_sequence_frame_data.CollectSequenceFrameData","title":"<code>CollectSequenceFrameData</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Collect Original Sequence Frame Data</p> <p>If the representation includes files with frame numbers, then set <code>frameStart</code> and <code>frameEnd</code> for the instance to the start and end frame respectively</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_sequence_frame_data.py</code> <pre><code>class CollectSequenceFrameData(\n    pyblish.api.InstancePlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Collect Original Sequence Frame Data\n\n    If the representation includes files with frame numbers,\n    then set `frameStart` and `frameEnd` for the instance to the\n    start and end frame respectively\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.4905\n    label = \"Collect Original Sequence Frame Data\"\n    families = [\"plate\", \"pointcache\",\n                \"vdbcache\", \"online\",\n                \"render\"]\n    hosts = [\"traypublisher\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # editorial would fail since they might not be in database yet\n        new_hierarchy = (\n            instance.data.get(\"newHierarchyIntegration\")\n            # Backwards compatible (Deprecated since 24/06/06)\n            or instance.data.get(\"newAssetPublishing\")\n        )\n        if new_hierarchy:\n            self.log.debug(\"Instance is creating new folders. Skipping.\")\n            return\n\n        frame_data = self.get_frame_data_from_repre_sequence(instance)\n\n        if not frame_data:\n            # if no dict data skip collecting the frame range data\n            return\n\n        for key, value in frame_data.items():\n            instance.data[key] = value\n            self.log.debug(f\"Collected Frame range data '{key}':{value} \")\n\n    def get_frame_data_from_repre_sequence(self, instance):\n        repres = instance.data.get(\"representations\")\n\n        entity: dict = (\n            instance.data.get(\"taskEntity\") or instance.data[\"folderEntity\"]\n        )\n        entity_attributes: dict = entity[\"attrib\"]\n\n        if repres:\n            first_repre = repres[0]\n            if \"ext\" not in first_repre:\n                self.log.warning(\"Cannot find file extension\"\n                                 \" in representation data\")\n                return\n\n            files = first_repre[\"files\"]\n            if not isinstance(files, list):\n                files = [files]\n\n            collections, _ = clique.assemble(files)\n            if not collections:\n                # No sequences detected and we can't retrieve\n                # frame range\n                self.log.debug(\n                    \"No sequences detected in the representation data.\"\n                    \" Skipping collecting frame range data.\")\n                return\n            collection = collections[0]\n            repres_frames = list(collection.indexes)\n\n            return {\n                \"frameStart\": repres_frames[0],\n                \"frameEnd\": repres_frames[-1],\n                \"handleStart\": 0,\n                \"handleEnd\": 0,\n                \"fps\": entity_attributes[\"fps\"]\n            }\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_shot_instances.html","title":"collect_shot_instances","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_shot_instances.html#client.ayon_traypublisher.plugins.publish.collect_shot_instances.CollectShotInstance","title":"<code>CollectShotInstance</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect shot instances</p> <p>Resolving its user inputs from creator attributes to instance data.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_shot_instances.py</code> <pre><code>class CollectShotInstance(pyblish.api.InstancePlugin):\n    \"\"\" Collect shot instances\n\n    Resolving its user inputs from creator attributes\n    to instance data.\n    \"\"\"\n\n    label = \"Collect Shot Instances\"\n    order = pyblish.api.CollectorOrder - 0.09\n\n    hosts = [\"traypublisher\"]\n    families = [\"shot\"]\n\n    SHARED_KEYS = [\n        \"folderPath\",\n        \"fps\",\n        \"handleStart\",\n        \"handleEnd\",\n        \"frameStart\",\n        \"frameEnd\",\n        \"clipIn\",\n        \"clipOut\",\n        \"clipDuration\",\n        \"sourceIn\",\n        \"sourceOut\",\n        \"otioClip\",\n        \"workfileFrameStart\"\n    ]\n\n    def process(self, instance):\n        creator_identifier = instance.data[\"creator_identifier\"]\n        if \"editorial\" not in creator_identifier:\n            return\n\n        # get otio clip object\n        otio_clip = self._get_otio_clip(instance)\n        instance.data[\"otioClip\"] = otio_clip\n\n        # first solve the inputs from creator attr\n        data = self._solve_inputs_to_data(instance)\n        instance.data.update(data)\n\n        # distribute all shared keys to clips instances\n        self._distribute_shared_data(instance)\n        self._solve_hierarchy_context(instance)\n\n        self.log.debug(pformat(instance.data))\n\n    def _get_otio_clip(self, instance):\n        \"\"\" Converts otio string data.\n\n        Convert them to proper otio object\n        and finds its equivalent at otio timeline.\n        This process is a hack to support also\n        resolving parent range.\n\n        Args:\n            instance (obj): publishing instance\n\n        Returns:\n            otio.Clip: otio clip object\n        \"\"\"\n        context = instance.context\n        # convert otio clip from string to object\n        otio_clip_string = instance.data.pop(\"otioClip\")\n        otio_clip = otio.adapters.read_from_string(\n            otio_clip_string)\n\n        otio_timeline = context.data[\"otioTimeline\"]\n\n        clips = [\n            clip for clip in otio_timeline.find_clips()\n            if clip.name == otio_clip.name\n            if clip.parent().kind == \"Video\"\n        ]\n\n        otio_clip = clips.pop()\n\n        return otio_clip\n\n    def _distribute_shared_data(self, instance):\n        \"\"\" Distribute all defined keys.\n\n        All data are shared between all related\n        instances in context.\n\n        Args:\n            instance (obj): publishing instance\n        \"\"\"\n        context = instance.context\n\n        instance_id = instance.data[\"instance_id\"]\n\n        if not context.data.get(\"editorialSharedData\"):\n            context.data[\"editorialSharedData\"] = {}\n\n        context.data[\"editorialSharedData\"][instance_id] = {\n            _k: _v for _k, _v in instance.data.items()\n            if _k in self.SHARED_KEYS\n        }\n\n    def _solve_inputs_to_data(self, instance):\n        \"\"\" Resolve all user inputs into instance data.\n\n        Args:\n            instance (obj): publishing instance\n\n        Returns:\n            dict: instance data updating data\n        \"\"\"\n        _cr_attrs = instance.data[\"creator_attributes\"]\n        workfile_start_frame = _cr_attrs[\"workfile_start_frame\"]\n        frame_start = _cr_attrs[\"frameStart\"]\n        frame_end = _cr_attrs[\"frameEnd\"]\n        frame_dur = frame_end - frame_start\n\n        return {\n            \"fps\": float(_cr_attrs[\"fps\"]),\n            \"handleStart\": _cr_attrs[\"handle_start\"],\n            \"handleEnd\": _cr_attrs[\"handle_end\"],\n            \"frameStart\": workfile_start_frame,\n            \"frameEnd\": workfile_start_frame + frame_dur,\n            \"clipIn\": _cr_attrs[\"clipIn\"],\n            \"clipOut\": _cr_attrs[\"clipOut\"],\n            \"clipDuration\": _cr_attrs[\"clipDuration\"],\n            \"sourceIn\": _cr_attrs[\"sourceIn\"],\n            \"sourceOut\": _cr_attrs[\"sourceOut\"],\n            \"workfileFrameStart\": workfile_start_frame,\n            \"folderPath\": _cr_attrs[\"folderPath\"],\n            \"integrate\": False,\n        }\n\n    def _solve_hierarchy_context(self, instance):\n        \"\"\" Adding hierarchy data to context shared data.\n\n        Args:\n            instance (obj): publishing instance\n        \"\"\"\n        context = instance.context\n\n        final_context = (\n            context.data[\"hierarchyContext\"]\n            if context.data.get(\"hierarchyContext\")\n            else {}\n        )\n\n        # get handles\n        handle_start = int(instance.data[\"handleStart\"])\n        handle_end = int(instance.data[\"handleEnd\"])\n\n        in_info = {\n            \"entity_type\": \"folder\",\n            \"folder_type\": \"Shot\",\n            \"attributes\": {\n                \"handleStart\": handle_start,\n                \"handleEnd\": handle_end,\n                \"frameStart\": instance.data[\"frameStart\"],\n                \"frameEnd\": instance.data[\"frameEnd\"],\n                \"clipIn\": instance.data[\"clipIn\"],\n                \"clipOut\": instance.data[\"clipOut\"],\n                \"fps\": instance.data[\"fps\"]\n            },\n            \"tasks\": instance.data[\"tasks\"]\n        }\n\n        parents = instance.data.get('parents', [])\n\n        folder_name = instance.data[\"folderPath\"].split(\"/\")[-1]\n        actual = {folder_name: in_info}\n\n        for parent in reversed(parents):\n            parent_name = parent[\"entity_name\"]\n            parent_info = {\n                \"entity_type\": parent[\"entity_type\"],\n                \"children\": actual,\n            }\n            if parent_info[\"entity_type\"] == \"folder\":\n                parent_info[\"folder_type\"] = parent[\"folder_type\"]\n            actual = {parent_name: parent_info}\n\n        final_context = self._update_dict(final_context, actual)\n\n        # adding hierarchy context to instance\n        context.data[\"hierarchyContext\"] = final_context\n\n    def _update_dict(self, ex_dict, new_dict):\n        \"\"\" Recursion function\n\n        Updating nested data with another nested data.\n\n        Args:\n            ex_dict (dict): nested data\n            new_dict (dict): nested data\n\n        Returns:\n            dict: updated nested data\n        \"\"\"\n        for key in ex_dict:\n            if key in new_dict and isinstance(ex_dict[key], dict):\n                new_dict[key] = self._update_dict(ex_dict[key], new_dict[key])\n            elif not ex_dict.get(key) or not new_dict.get(key):\n                new_dict[key] = ex_dict[key]\n\n        return new_dict\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_simple_instances.html","title":"collect_simple_instances","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_simple_instances.html#client.ayon_traypublisher.plugins.publish.collect_simple_instances.CollectSettingsSimpleInstances","title":"<code>CollectSettingsSimpleInstances</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect data for instances created by settings creators.</p> <p>Plugin create representations for simple instances based on 'representation_files' attribute stored on instance data.</p> <p>There is also possibility to have reviewable representation which can be stored under 'reviewable' attribute stored on instance data. If there was already created representation with the same files as 'reviewable' contains</p> <p>Representations can be marked for review and in that case is also added 'review' family to instance families. For review can be marked only one representation so first representation that has extension available in '_review_extensions' is used for review.</p> <p>For instance 'source' is used path from last representation created from 'representation_files'.</p> <p>Set staging directory on instance. That is probably never used because each created representation has it's own staging dir.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_simple_instances.py</code> <pre><code>class CollectSettingsSimpleInstances(pyblish.api.InstancePlugin):\n    \"\"\"Collect data for instances created by settings creators.\n\n    Plugin create representations for simple instances based\n    on 'representation_files' attribute stored on instance data.\n\n    There is also possibility to have reviewable representation which can be\n    stored under 'reviewable' attribute stored on instance data. If there was\n    already created representation with the same files as 'reviewable' contains\n\n    Representations can be marked for review and in that case is also added\n    'review' family to instance families. For review can be marked only one\n    representation so **first** representation that has extension available\n    in '_review_extensions' is used for review.\n\n    For instance 'source' is used path from last representation created\n    from 'representation_files'.\n\n    Set staging directory on instance. That is probably never used because\n    each created representation has it's own staging dir.\n    \"\"\"\n\n    label = \"Collect Settings Simple Instances\"\n    order = pyblish.api.CollectorOrder - 0.49\n\n    hosts = [\"traypublisher\"]\n\n    def process(self, instance):\n        if not instance.data.get(\"settings_creator\"):\n            return\n\n        instance_label = instance.data[\"name\"]\n        # Create instance's staging dir in temp\n        tmp_folder = tempfile.mkdtemp(prefix=\"traypublisher_\")\n        instance.data[\"stagingDir\"] = tmp_folder\n        instance.context.data[\"cleanupFullPaths\"].append(tmp_folder)\n\n        self.log.debug((\n            \"Created temp staging directory for instance {}. {}\"\n        ).format(instance_label, tmp_folder))\n\n        self._fill_version(instance, instance_label)\n\n        # Store filepaths for validation of their existence\n        source_filepaths = []\n        # Make sure there are no representations with same name\n        repre_names_counter = {}\n        # Store created names for logging\n        repre_names = []\n        # Store set of filepaths per each representation\n        representation_files_mapping = []\n        source = self._create_main_representations(\n            instance,\n            source_filepaths,\n            repre_names_counter,\n            repre_names,\n            representation_files_mapping\n        )\n\n        self._create_review_representation(\n            instance,\n            source_filepaths,\n            repre_names_counter,\n            repre_names,\n            representation_files_mapping\n        )\n        source_filepaths = list(set(source_filepaths))\n        instance.data[\"source\"] = source\n        instance.data[\"sourceFilepaths\"] = source_filepaths\n\n        # NOTE: Missing filepaths should not cause crashes (at least not here)\n        # - if filepaths are required they should crash on validation\n        if source_filepaths:\n            # NOTE: Original basename is not handling sequences\n            # - we should maybe not fill the key when sequence is used?\n            origin_basename = Path(source_filepaths[0]).stem\n            instance.data[\"originalBasename\"] = origin_basename\n\n        # Special test for SXR format.\n        # The following code can be removed as soon as a new\n        # ayon-core dependency is set on ayon-traypublisher.\n        # https://github.com/ynput/ayon-traypublisher/issues/77\n        for repre in instance.data[\"representations\"]:\n            if (\n                repre[\"ext\"].lower() == \"sxr\"\n                and \".sxr\" not in transcoding.IMAGE_EXTENSIONS\n            ):\n                raise PublishError(\n                    \"SXR extension is not supported. Update\"\n                    \" ayon-core in order to fix this.\"\n                )\n\n        self.log.debug(\n            (\n                \"Created Simple Settings instance \\\"{}\\\"\"\n                \" with {} representations: {}\"\n            ).format(\n                instance_label,\n                len(instance.data[\"representations\"]),\n                \", \".join(repre_names)\n            )\n        )\n\n    def _fill_version(self, instance, instance_label):\n        \"\"\"Fill instance version under which will be instance integrated.\n\n        Instance must have set 'use_next_version' to 'False'\n        and 'version_to_use' to version to use.\n\n        Args:\n            instance (pyblish.api.Instance): Instance to fill version for.\n            instance_label (str): Label of instance to fill version for.\n        \"\"\"\n\n        creator_attributes = instance.data[\"creator_attributes\"]\n        use_next_version = creator_attributes.get(\"use_next_version\", True)\n        # If 'version_to_use' is '0' it means that next version should be used\n        version_to_use = creator_attributes.get(\"version_to_use\", 0)\n        if use_next_version or not version_to_use:\n            return\n        instance.data[\"version\"] = version_to_use\n        self.log.debug(\n            \"Version for instance \\\"{}\\\" was set to \\\"{}\\\"\".format(\n                instance_label, version_to_use))\n\n    def _create_main_representations(\n        self,\n        instance,\n        source_filepaths,\n        repre_names_counter,\n        repre_names,\n        representation_files_mapping\n    ):\n        creator_attributes = instance.data[\"creator_attributes\"]\n        filepath_items = creator_attributes[\"representation_files\"]\n        if not isinstance(filepath_items, list):\n            filepath_items = [filepath_items]\n\n        source = None\n        for filepath_item in filepath_items:\n            # Skip if filepath item does not have filenames\n            if not filepath_item[\"filenames\"]:\n                continue\n\n            filepaths = {\n                os.path.join(filepath_item[\"directory\"], filename)\n                for filename in filepath_item[\"filenames\"]\n            }\n            source_filepaths.extend(filepaths)\n\n            source = self._calculate_source(filepaths)\n            representation = self._create_representation_data(\n                filepath_item, repre_names_counter, repre_names\n            )\n            instance.data[\"representations\"].append(representation)\n            representation_files_mapping.append(\n                (filepaths, representation, source)\n            )\n        return source\n\n    def _create_review_representation(\n        self,\n        instance,\n        source_filepaths,\n        repre_names_counter,\n        repre_names,\n        representation_files_mapping\n    ):\n        # Skip review representation creation if there are no representations\n        #   created for \"main\" part\n        #   - review representation must not be created in that case so\n        #       validation can care about it\n        if not representation_files_mapping:\n            self.log.warning((\n                \"There are missing source representations.\"\n                \" Creation of review representation was skipped.\"\n            ))\n            return\n\n        creator_attributes = instance.data[\"creator_attributes\"]\n        review_file_item = creator_attributes[\"reviewable\"]\n        filenames = review_file_item.get(\"filenames\")\n        if not filenames:\n            self.log.debug((\n                \"Filepath for review is not defined.\"\n                \" Skipping review representation creation.\"\n            ))\n            return\n\n        item_dir = review_file_item[\"directory\"]\n        first_filepath = os.path.join(item_dir, filenames[0])\n\n        filepaths = {\n            os.path.join(item_dir, filename)\n            for filename in filenames\n        }\n        source_filepaths.extend(filepaths)\n        # First try to find out representation with same filepaths\n        #   so it's not needed to create new representation just for review\n        use_source_as_review = False\n        review_representation = None\n        # Review path (only for logging)\n        review_path = None\n        for item in representation_files_mapping:\n            _filepaths, representation, repre_path = item\n            if _filepaths == filepaths:\n                review_representation = representation\n                review_path = repre_path\n                use_source_as_review = True\n                break\n\n        if review_representation is None:\n            self.log.debug(\"Creating new review representation\")\n            review_path = self._calculate_source(filepaths)\n            review_representation = self._create_representation_data(\n                review_file_item, repre_names_counter, repre_names\n            )\n            instance.data[\"representations\"].append(review_representation)\n\n        if \"review\" not in instance.data[\"families\"]:\n            instance.data[\"families\"].append(\"review\")\n\n        if not instance.data.get(\"thumbnailSource\"):\n            instance.data[\"thumbnailSource\"] = first_filepath\n\n        review_representation[\"tags\"].append(\"review\")\n\n        # Adding \"review\" to representation name since it can clash with main\n        # representation if they share the same extension.\n        if not use_source_as_review:\n            review_representation[\"outputName\"] = \"review\"\n\n        self.log.debug(\"Representation {} was marked for review. {}\".format(\n            review_representation[\"name\"], review_path\n        ))\n\n    def _create_representation_data(\n        self, filepath_item, repre_names_counter, repre_names\n    ):\n        \"\"\"Create new representation data based on file item.\n\n        Args:\n            filepath_item (Dict[str, Any]): Item with information about\n                representation paths.\n            repre_names_counter (Dict[str, int]): Store count of representation\n                names.\n            repre_names (List[str]): All used representation names. For\n                logging purposes.\n\n        Returns:\n            Dict: Prepared base representation data.\n        \"\"\"\n\n        filenames = filepath_item[\"filenames\"]\n        _, ext = os.path.splitext(filenames[0])\n        if len(filenames) == 1:\n            filenames = filenames[0]\n\n        repre_name = repre_ext = ext[1:]\n        if repre_name not in repre_names_counter:\n            repre_names_counter[repre_name] = 2\n            counter = None\n        else:\n            counter = repre_names_counter[repre_name]\n            repre_names_counter[repre_name] += 1\n            repre_name = \"{}_{}\".format(repre_name, counter)\n        repre_names.append(repre_name)\n        representation_data = {\n            \"ext\": repre_ext,\n            \"name\": repre_name,\n            \"stagingDir\": filepath_item[\"directory\"],\n            \"files\": filenames,\n            \"tags\": []\n        }\n\n        if counter:\n            representation_data[\"outputName\"] = str(counter)\n\n        return representation_data\n\n    def _calculate_source(self, filepaths):\n        cols, rems = clique.assemble(filepaths)\n        if cols:\n            source = cols[0].format(\"{head}{padding}{tail}\")\n        elif rems:\n            source = rems[0]\n        return source\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_source.html","title":"collect_source","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/collect_source.html#client.ayon_traypublisher.plugins.publish.collect_source.CollectSource","title":"<code>CollectSource</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collecting instances from traypublisher host.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/collect_source.py</code> <pre><code>class CollectSource(pyblish.api.ContextPlugin):\n    \"\"\"Collecting instances from traypublisher host.\"\"\"\n\n    label = \"Collect source\"\n    order = pyblish.api.CollectorOrder - 0.49\n    hosts = [\"traypublisher\"]\n\n    def process(self, context):\n        # get json paths from os and load them\n        source_name = \"traypublisher\"\n        for instance in context:\n            source = instance.data.get(\"source\")\n            if not source:\n                instance.data[\"source\"] = source_name\n                self.log.info((\n                    \"Source of instance \\\"{}\\\" is changed to \\\"{}\\\"\"\n                ).format(instance.data[\"name\"], source_name))\n            else:\n                self.log.info((\n                    \"Source of instance \\\"{}\\\" was already set to \\\"{}\\\"\"\n                ).format(instance.data[\"name\"], source))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/extract_colorspace_look.html","title":"extract_colorspace_look","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/extract_colorspace_look.html#client.ayon_traypublisher.plugins.publish.extract_colorspace_look.ExtractColorspaceLook","title":"<code>ExtractColorspaceLook</code>","text":"<p>               Bases: <code>Extractor</code>, <code>AYONPyblishPluginMixin</code></p> <p>Extract OCIO colorspace look from LUT file</p> Source code in <code>client/ayon_traypublisher/plugins/publish/extract_colorspace_look.py</code> <pre><code>class ExtractColorspaceLook(publish.Extractor,\n                            publish.AYONPyblishPluginMixin):\n    \"\"\"Extract OCIO colorspace look from LUT file\n    \"\"\"\n\n    label = \"Extract Colorspace Look\"\n    order = pyblish.api.ExtractorOrder\n    hosts = [\"traypublisher\"]\n    families = [\"ociolook\"]\n\n    def process(self, instance):\n        ociolook_items = instance.data[\"ocioLookItems\"]\n        ociolook_working_color = instance.data[\"ocioLookWorkingSpace\"]\n        staging_dir = self.staging_dir(instance)\n\n        # create ociolook file attributes\n        ociolook_file_name = \"ocioLookFile.json\"\n        ociolook_file_content = {\n            \"version\": 1,\n            \"data\": {\n                \"ocioLookItems\": ociolook_items,\n                \"ocioLookWorkingSpace\": ociolook_working_color\n            }\n        }\n\n        # write ociolook content into json file saved in staging dir\n        file_url = os.path.join(staging_dir, ociolook_file_name)\n        with open(file_url, \"w\") as f_:\n            json.dump(ociolook_file_content, f_, indent=4)\n\n        # create lut representation data\n        ociolook_repre = {\n            \"name\": \"ocioLookFile\",\n            \"ext\": \"json\",\n            \"files\": ociolook_file_name,\n            \"stagingDir\": staging_dir,\n            \"tags\": []\n        }\n        instance.data[\"representations\"].append(ociolook_repre)\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/extract_csv_file.html","title":"extract_csv_file","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/extract_csv_file.html#client.ayon_traypublisher.plugins.publish.extract_csv_file.ExtractCSVFile","title":"<code>ExtractCSVFile</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extractor export CSV file</p> Source code in <code>client/ayon_traypublisher/plugins/publish/extract_csv_file.py</code> <pre><code>class ExtractCSVFile(publish.Extractor):\n    \"\"\"\n    Extractor export CSV file\n    \"\"\"\n\n    label = \"Extract CSV file\"\n    order = pyblish.api.ExtractorOrder - 0.45\n    families = [\"csv_ingest_file\"]\n    hosts = [\"traypublisher\"]\n\n    def process(self, instance):\n\n        csv_file_data = instance.data[\"csvFileData\"]\n\n        representation_csv = {\n            'name': \"csv_data\",\n            'ext': \"csv\",\n            'files': csv_file_data[\"filename\"],\n            \"stagingDir\": csv_file_data[\"staging_dir\"],\n            \"stagingDir_persistent\": True\n        }\n\n        instance.data[\"representations\"].append(representation_csv)\n\n        self.log.info(\"Added CSV file representation: {}\".format(\n            representation_csv))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/extract_editorial_pckg.html","title":"extract_editorial_pckg","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/extract_editorial_pckg.html#client.ayon_traypublisher.plugins.publish.extract_editorial_pckg.ExtractEditorialPckgConversion","title":"<code>ExtractEditorialPckgConversion</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Replaces movie paths in otio file with publish rootless</p> <p>Prepares movie resources for integration (adds them to <code>transfers</code>). Converts .mov files according to output definition.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/extract_editorial_pckg.py</code> <pre><code>class ExtractEditorialPckgConversion(publish.Extractor):\n    \"\"\"Replaces movie paths in otio file with publish rootless\n\n    Prepares movie resources for integration (adds them to `transfers`).\n    Converts .mov files according to output definition.\n    \"\"\"\n\n    label = \"Extract Editorial Package\"\n    order = pyblish.api.ExtractorOrder - 0.45\n    hosts = [\"traypublisher\"]\n    families = [\"editorial_pkg\"]\n\n    def process(self, instance):\n        editorial_pkg_data = instance.data.get(\"editorial_pkg\")\n\n        otio_path = editorial_pkg_data[\"otio_path\"]\n        otio_basename = os.path.basename(otio_path)\n        staging_dir = self.staging_dir(instance)\n\n        editorial_pkg_repre = {\n            'name': \"editorial_pkg\",\n            'ext': \"otio\",\n            'files': otio_basename,\n            \"stagingDir\": staging_dir,\n        }\n        otio_staging_path = os.path.join(staging_dir, otio_basename)\n\n        instance.data[\"representations\"].append(editorial_pkg_repre)\n\n        publish_resource_folder = self._get_publish_resource_folder(instance)\n        resource_paths = editorial_pkg_data[\"resource_paths\"]\n        transfers = self._get_transfers(resource_paths,\n                                        publish_resource_folder)\n\n        project_settings = instance.context.data[\"project_settings\"]\n        output_def = (project_settings[\"traypublisher\"]\n                                      [\"publish\"]\n                                      [\"ExtractEditorialPckgConversion\"]\n                                      [\"output\"])\n\n        conversion_enabled = (instance.data[\"creator_attributes\"]\n                                           [\"conversion_enabled\"])\n\n        if conversion_enabled and output_def[\"ext\"]:\n            transfers = self._convert_resources(output_def, transfers)\n\n        instance.data[\"transfers\"] = transfers\n\n        source_to_rootless = self._get_resource_path_mapping(instance,\n                                                             transfers)\n\n        otio_data = editorial_pkg_data[\"otio_data\"]\n        otio_data = self._replace_target_urls(otio_data, source_to_rootless)\n\n        opentimelineio.adapters.write_to_file(otio_data, otio_staging_path)\n\n        self.log.info(\"Added Editorial Package representation: {}\".format(\n            editorial_pkg_repre))\n\n    def _get_publish_resource_folder(self, instance):\n        \"\"\"Calculates publish folder and create it.\"\"\"\n        publish_path = self._get_published_path(instance)\n        publish_folder = os.path.dirname(publish_path)\n        publish_resource_folder = os.path.join(publish_folder, \"resources\")\n\n        if not os.path.exists(publish_resource_folder):\n            os.makedirs(publish_resource_folder, exist_ok=True)\n        return publish_resource_folder\n\n    def _get_resource_path_mapping(self, instance, transfers):\n        \"\"\"Returns dict of {source_mov_path: rootless_published_path}.\"\"\"\n        replace_paths = {}\n        anatomy = instance.context.data[\"anatomy\"]\n        for source, destination in transfers:\n            rootless_path = self._get_rootless(anatomy, destination)\n            source_file_name = os.path.basename(source)\n            replace_paths[source_file_name] = rootless_path\n        return replace_paths\n\n    def _get_transfers(self, resource_paths, publish_resource_folder):\n        \"\"\"Returns list of tuples (source, destination) with movie paths.\"\"\"\n        transfers = []\n        for res_path in resource_paths:\n            res_basename = os.path.basename(res_path)\n            pub_res_path = os.path.join(publish_resource_folder, res_basename)\n            transfers.append((res_path, pub_res_path))\n        return transfers\n\n    def _replace_target_urls(self, otio_data, replace_paths):\n        \"\"\"Replace original movie paths with published rootless ones.\"\"\"\n        for track in otio_data.tracks:\n            for clip in track:\n                # Check if the clip has a media reference\n                if clip.media_reference is not None:\n                    # Access the target_url from the media reference\n                    target_url = clip.media_reference.target_url\n                    if not target_url:\n                        continue\n                    file_name = os.path.basename(target_url)\n                    replace_path = replace_paths.get(file_name)\n                    if replace_path:\n                        clip.media_reference.target_url = replace_path\n                        if clip.name == file_name:\n                            clip.name = os.path.basename(replace_path)\n\n        return otio_data\n\n    def _get_rootless(self, anatomy, path):\n        \"\"\"Try to find rootless {root[work]} path from `path`\"\"\"\n        success, rootless_path = anatomy.find_root_template_from_path(\n            path)\n        if not success:\n            # `rootless_path` is not set to `output_dir` if none of roots match\n            self.log.warning(\n               f\"Could not find root path for remapping '{path}'.\"\n            )\n            rootless_path = path\n\n        return rootless_path\n\n    def _get_published_path(self, instance):\n        \"\"\"Calculates expected `publish` folder\"\"\"\n        # determine published path from Anatomy.\n        template_data = instance.data.get(\"anatomyData\")\n        rep = instance.data[\"representations\"][0]\n        template_data[\"representation\"] = rep.get(\"name\")\n        template_data[\"ext\"] = rep.get(\"ext\")\n        template_data[\"comment\"] = None\n\n        anatomy = instance.context.data[\"anatomy\"]\n        template_data[\"root\"] = anatomy.roots\n        template = anatomy.get_template_item(\"publish\", \"default\", \"path\")\n        template_filled = template.format_strict(template_data)\n        return os.path.normpath(template_filled)\n\n    def _convert_resources(self, output_def, transfers):\n        \"\"\"Converts all resource files to configured format.\"\"\"\n        out_extension = output_def[\"ext\"]\n        if not out_extension:\n            self.log.warning(\"No output extension configured in \"\n               \"ayon+settings://traypublisher/publish/ExtractEditorialPckgConversion\")  # noqa\n            return transfers\n\n        final_transfers = []\n        out_def_ffmpeg_args = output_def[\"ffmpeg_args\"]\n        ffmpeg_input_args = [\n            value.strip()\n            for value in out_def_ffmpeg_args[\"input\"]\n            if value.strip()\n        ]\n        ffmpeg_video_filters = [\n            value.strip()\n            for value in out_def_ffmpeg_args[\"video_filters\"]\n            if value.strip()\n        ]\n        ffmpeg_audio_filters = [\n            value.strip()\n            for value in out_def_ffmpeg_args[\"audio_filters\"]\n            if value.strip()\n        ]\n        ffmpeg_output_args = [\n            value.strip()\n            for value in out_def_ffmpeg_args[\"output\"]\n            if value.strip()\n        ]\n        ffmpeg_input_args = self._split_ffmpeg_args(ffmpeg_input_args)\n\n        generic_args = [\n            subprocess.list2cmdline(get_ffmpeg_tool_args(\"ffmpeg\"))\n        ]\n        generic_args.extend(ffmpeg_input_args)\n        if ffmpeg_video_filters:\n            generic_args.append(\"-filter:v\")\n            generic_args.append(\n                \"\\\"{}\\\"\".format(\",\".join(ffmpeg_video_filters)))\n\n        if ffmpeg_audio_filters:\n            generic_args.append(\"-filter:a\")\n            generic_args.append(\n                \"\\\"{}\\\"\".format(\",\".join(ffmpeg_audio_filters)))\n\n        for source, destination in transfers:\n            base_name = os.path.basename(destination)\n            file_name, ext = os.path.splitext(base_name)\n            dest_path = os.path.join(os.path.dirname(destination),\n                                     f\"{file_name}.{out_extension}\")\n            final_transfers.append((source, dest_path))\n\n            all_args = copy.deepcopy(generic_args)\n            all_args.append(f\"-i \\\"{source}\\\"\")\n            all_args.extend(ffmpeg_output_args)  # order matters\n            all_args.append(f\"\\\"{dest_path}\\\"\")\n            subprcs_cmd = \" \".join(all_args)\n\n            # run subprocess\n            self.log.debug(\"Executing: {}\".format(subprcs_cmd))\n            run_subprocess(subprcs_cmd, shell=True, logger=self.log)\n        return final_transfers\n\n    def _split_ffmpeg_args(self, in_args):\n        \"\"\"Makes sure all entered arguments are separated in individual items.\n\n        Split each argument string with \" -\" to identify if string contains\n        one or more arguments.\n        \"\"\"\n        splitted_args = []\n        for arg in in_args:\n            sub_args = arg.split(\" -\")\n            if len(sub_args) == 1:\n                if arg and arg not in splitted_args:\n                    splitted_args.append(arg)\n                continue\n\n            for idx, arg in enumerate(sub_args):\n                if idx != 0:\n                    arg = \"-\" + arg\n\n                if arg and arg not in splitted_args:\n                    splitted_args.append(arg)\n        return splitted_args\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/extract_trim_video_audio.html","title":"extract_trim_video_audio","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/extract_trim_video_audio.html#client.ayon_traypublisher.plugins.publish.extract_trim_video_audio.ExtractTrimVideoAudio","title":"<code>ExtractTrimVideoAudio</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Trim with ffmpeg \"mov\" and \"wav\" files.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/extract_trim_video_audio.py</code> <pre><code>class ExtractTrimVideoAudio(publish.Extractor):\n    \"\"\"Trim with ffmpeg \"mov\" and \"wav\" files.\"\"\"\n\n    # must be before `ExtractThumbnailSP`\n    order = pyblish.api.ExtractorOrder - 0.01\n    label = \"Extract Trim Video/Audio\"\n    hosts = [\"traypublisher\"]\n    families = [\"clip\", \"trimming\"]\n\n    # make sure it is enabled only if at least both families are available\n    match = pyblish.api.Subset\n\n    # presets\n\n    def process(self, instance):\n        representation = instance.data.get(\"representations\")\n        self.log.debug(f\"_ representation: {representation}\")\n\n        if not representation:\n            instance.data[\"representations\"] = list()\n\n        # get ffmpet path\n        ffmpeg_tool_args = get_ffmpeg_tool_args(\"ffmpeg\")\n\n        # get staging dir\n        staging_dir = self.staging_dir(instance)\n        self.log.debug(\"Staging dir set to: `{}`\".format(staging_dir))\n\n        # Generate mov file.\n        fps = instance.data[\"fps\"]\n        video_file_path = instance.data[\"editorialSourcePath\"]\n        extensions = instance.data.get(\"extensions\", [\"mov\"])\n        output_file_type = instance.data.get(\"outputFileType\")\n        reviewable = \"review\" in instance.data[\"families\"]\n\n        frame_start = int(instance.data[\"frameStart\"])\n        frame_end = int(instance.data[\"frameEnd\"])\n        handle_start = instance.data[\"handleStart\"]\n        handle_end = instance.data[\"handleEnd\"]\n\n        clip_start_h = float(instance.data[\"clipInH\"])\n        _dur = instance.data[\"clipDuration\"]\n        handle_dur = (handle_start + handle_end)\n        clip_dur_h = float(_dur + handle_dur)\n\n        if output_file_type:\n            extensions = [output_file_type]\n\n        for ext in extensions:\n            self.log.debug(\"Processing ext: `{}`\".format(ext))\n\n            if not ext.startswith(\".\"):\n                ext = \".\" + ext\n\n            clip_trimed_path = os.path.join(\n                staging_dir, instance.data[\"name\"] + ext)\n\n            if ext == \".wav\":\n                # offset time as ffmpeg is having bug\n                clip_start_h += 0.5\n                # remove \"review\" from families\n                instance.data[\"families\"] = [\n                    fml for fml in instance.data[\"families\"]\n                    if \"trimming\" not in fml\n                ]\n\n            ffmpeg_args = ffmpeg_tool_args + [\n                \"-ss\", str(clip_start_h / fps),\n                \"-i\", video_file_path,\n                \"-t\", str(clip_dur_h / fps)\n            ]\n            if ext in [\".mov\", \".mp4\"]:\n                ffmpeg_args.extend([\n                    \"-crf\", \"18\",\n                    \"-pix_fmt\", \"yuv420p\"\n                ])\n            elif ext in \".wav\":\n                ffmpeg_args.extend([\n                    \"-vn\",\n                    \"-acodec\", \"pcm_s16le\",\n                    \"-ar\", \"48000\",\n                    \"-ac\", \"2\"\n                ])\n\n            # add output path\n            ffmpeg_args.append(clip_trimed_path)\n\n            joined_args = \" \".join(ffmpeg_args)\n            self.log.debug(f\"Processing: {joined_args}\")\n            run_subprocess(\n                ffmpeg_args, logger=self.log\n            )\n\n            repre = {\n                \"name\": ext[1:],\n                \"ext\": ext[1:],\n                \"files\": os.path.basename(clip_trimed_path),\n                \"stagingDir\": staging_dir,\n                \"frameStart\": frame_start,\n                \"frameEnd\": frame_end,\n                \"frameStartFtrack\": frame_start - handle_start,\n                \"frameEndFtrack\": frame_end + handle_end,\n                \"fps\": fps,\n                \"tags\": []\n            }\n\n            if ext in [\".mov\", \".mp4\"] and reviewable:\n                repre.update({\n                    \"thumbnail\": True,\n                    \"tags\": [\"review\", \"ftrackreview\", \"delete\"]})\n\n            instance.data[\"representations\"].append(repre)\n\n            self.log.debug(f\"Instance data: {pformat(instance.data)}\")\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_colorspace.html","title":"validate_colorspace","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_colorspace.html#client.ayon_traypublisher.plugins.publish.validate_colorspace.ValidateColorspace","title":"<code>ValidateColorspace</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Validate representation colorspaces</p> Source code in <code>client/ayon_traypublisher/plugins/publish/validate_colorspace.py</code> <pre><code>class ValidateColorspace(pyblish.api.InstancePlugin,\n                         publish.AYONPyblishPluginMixin,\n                         publish.ColormanagedPyblishPluginMixin):\n    \"\"\"Validate representation colorspaces\"\"\"\n\n    label = \"Validate representation colorspace\"\n    order = pyblish.api.ValidatorOrder\n    hosts = [\"traypublisher\"]\n    families = [\"render\", \"plate\", \"reference\", \"image\", \"online\"]\n\n    def process(self, instance):\n\n        config_colorspaces = {}  # cache of colorspaces per config path\n        for repre in instance.data.get(\"representations\", {}):\n\n            colorspace_data = repre.get(\"colorspaceData\", {})\n            if not colorspace_data:\n                # Nothing to validate\n                continue\n\n            config_path = colorspace_data[\"config\"][\"path\"]\n            if config_path not in config_colorspaces:\n                colorspaces = get_ocio_config_colorspaces(config_path)\n                if not colorspaces.get(\"colorspaces\"):\n                    message = (\n                        f\"OCIO config '{config_path}' does not contain any \"\n                        \"colorspaces. This is an error in the OCIO config. \"\n                        \"Contact your pipeline TD.\",\n                    )\n                    raise PublishValidationError(\n                        title=\"Colorspace validation\",\n                        message=message,\n                        description=message\n                    )\n                config_colorspaces[config_path] = set(\n                    colorspaces[\"colorspaces\"])\n\n            colorspace = colorspace_data[\"colorspace\"]\n            self.log.debug(\n                f\"Validating representation '{repre['name']}' \"\n                f\"colorspace '{colorspace}'\"\n            )\n            if colorspace not in config_colorspaces[config_path]:\n                message = (\n                    f\"Representation '{repre['name']}' colorspace \"\n                    f\"'{colorspace}' does not exist in OCIO config: \"\n                    f\"{config_path}\"\n                )\n\n                raise PublishValidationError(\n                    title=\"Representation colorspace\",\n                    message=message,\n                    description=message\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_colorspace_look.html","title":"validate_colorspace_look","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_colorspace_look.html#client.ayon_traypublisher.plugins.publish.validate_colorspace_look.ValidateColorspaceLook","title":"<code>ValidateColorspaceLook</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Validate colorspace look attributes</p> Source code in <code>client/ayon_traypublisher/plugins/publish/validate_colorspace_look.py</code> <pre><code>class ValidateColorspaceLook(pyblish.api.InstancePlugin,\n                             publish.AYONPyblishPluginMixin):\n    \"\"\"Validate colorspace look attributes\"\"\"\n\n    label = \"Validate colorspace look attributes\"\n    order = pyblish.api.ValidatorOrder\n    hosts = [\"traypublisher\"]\n    families = [\"ociolook\"]\n\n    def process(self, instance):\n        create_context = instance.context.data[\"create_context\"]\n        created_instance = create_context.get_instance_by_id(\n            instance.data[\"instance_id\"])\n        creator_defs = created_instance.creator_attribute_defs\n\n        ociolook_working_color = instance.data.get(\"ocioLookWorkingSpace\")\n        ociolook_items = instance.data.get(\"ocioLookItems\", [])\n\n        creator_defs_by_key = {_def.key: _def.label for _def in creator_defs}\n\n        not_set_keys = {}\n        if not ociolook_working_color:\n            not_set_keys[\"working_colorspace\"] = creator_defs_by_key[\n                \"working_colorspace\"]\n\n        for ociolook_item in ociolook_items:\n            item_not_set_keys = self.validate_colorspace_set_attrs(\n                ociolook_item\n            )\n            if item_not_set_keys:\n                not_set_keys[ociolook_item[\"name\"]] = item_not_set_keys\n\n        if not_set_keys:\n            message = (\n                \"Colorspace look attributes are not set: \\n\"\n            )\n            for key, value in not_set_keys.items():\n                if isinstance(value, list):\n                    values_string = \"\\n\\t- \".join(value)\n                    message += f\"\\n\\t{key}:\\n\\t- {values_string}\"\n                else:\n                    message += f\"\\n\\t{value}\"\n\n            raise PublishValidationError(\n                title=\"Colorspace Look attributes\",\n                message=message,\n                description=message\n            )\n\n    def validate_colorspace_set_attrs(\n        self,\n        ociolook_item,\n    ):\n        \"\"\"Validate colorspace look attributes\"\"\"\n\n        self.log.debug(f\"Validate colorspace look attributes: {ociolook_item}\")\n\n        check_keys = [\n            \"input_colorspace\",\n            \"output_colorspace\",\n            \"direction\",\n            \"interpolation\"\n        ]\n\n        not_set_keys = []\n        for key in check_keys:\n            if ociolook_item.get(key):\n                # key is set and it is correct\n                continue\n\n            not_set_keys.append(key)\n\n        return not_set_keys\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_colorspace_look.html#client.ayon_traypublisher.plugins.publish.validate_colorspace_look.ValidateColorspaceLook.validate_colorspace_set_attrs","title":"<code>validate_colorspace_set_attrs(ociolook_item)</code>","text":"<p>Validate colorspace look attributes</p> Source code in <code>client/ayon_traypublisher/plugins/publish/validate_colorspace_look.py</code> <pre><code>def validate_colorspace_set_attrs(\n    self,\n    ociolook_item,\n):\n    \"\"\"Validate colorspace look attributes\"\"\"\n\n    self.log.debug(f\"Validate colorspace look attributes: {ociolook_item}\")\n\n    check_keys = [\n        \"input_colorspace\",\n        \"output_colorspace\",\n        \"direction\",\n        \"interpolation\"\n    ]\n\n    not_set_keys = []\n    for key in check_keys:\n        if ociolook_item.get(key):\n            # key is set and it is correct\n            continue\n\n        not_set_keys.append(key)\n\n    return not_set_keys\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_editorial_package.html","title":"validate_editorial_package","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_editorial_package.html#client.ayon_traypublisher.plugins.publish.validate_editorial_package.ValidateEditorialPackage","title":"<code>ValidateEditorialPackage</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Checks that published folder contains all resources from otio</p> <p>Currently checks only by file names and expects flat structure. It ignores path to resources in otio file as folder might be dragged in and published from different location than it was created.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/validate_editorial_package.py</code> <pre><code>class ValidateEditorialPackage(pyblish.api.InstancePlugin):\n    \"\"\"Checks that published folder contains all resources from otio\n\n    Currently checks only by file names and expects flat structure.\n    It ignores path to resources in otio file as folder might be dragged in and\n    published from different location than it was created.\n    \"\"\"\n\n    label = \"Validate Editorial Package\"\n    order = pyblish.api.ValidatorOrder - 0.49\n\n    hosts = [\"traypublisher\"]\n    families = [\"editorial_pkg\"]\n\n    def process(self, instance):\n        editorial_pkg_data = instance.data.get(\"editorial_pkg\")\n        if not editorial_pkg_data:\n            raise PublishValidationError(\"Editorial package not collected\")\n\n        folder_path = editorial_pkg_data[\"folder_path\"]\n\n        otio_path = editorial_pkg_data[\"otio_path\"]\n        if not otio_path:\n            raise PublishValidationError(\n                f\"Folder {folder_path} missing otio file\")\n\n        resource_paths = editorial_pkg_data[\"resource_paths\"]\n\n        resource_file_names = {os.path.basename(path)\n                               for path in resource_paths}\n\n        try:\n            otio_data = opentimelineio.adapters.read_from_file(otio_path)\n        except UnsupportedSchemaError as e:\n            raise PublishValidationError(\n                f\"Unsupported schema in otio file '{otio_path}'.\"\n                \"Version of your OpenTimelineIO library is too old.\"\n                \"Please update it to the latest version.\"\n                f\"Current version is '{opentimelineio.__version__}', \"\n                \"but required is at least 0.16.0.\"\n            ) from e\n\n        target_urls = self._get_all_target_urls(otio_data)\n        missing_files = set()\n        for target_url in target_urls:\n            target_basename = os.path.basename(target_url)\n            if target_basename not in resource_file_names:\n                missing_files.add(target_basename)\n\n        if missing_files:\n            raise PublishValidationError(\n                f\"Otio file contains missing files `{missing_files}`.\\n\\n\"\n                f\"Please add them to `{folder_path}` and republish.\")\n\n        instance.data[\"editorial_pkg\"][\"otio_data\"] = otio_data\n\n    def _get_all_target_urls(self, otio_data):\n        target_urls = []\n\n        # Iterate through tracks, clips, or other elements\n        for track in otio_data.tracks:\n            for clip in track:\n                # Check if the clip has a media reference\n                if clip.media_reference is not None:\n                    # Access the target_url from the media reference\n                    target_url = clip.media_reference.target_url\n                    if target_url:\n                        target_urls.append(target_url)\n\n        return target_urls\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_existing_version.html","title":"validate_existing_version","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_filepaths.html","title":"validate_filepaths","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_filepaths.html#client.ayon_traypublisher.plugins.publish.validate_filepaths.ValidateFilePath","title":"<code>ValidateFilePath</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate existence of source filepaths on instance.</p> <p>Plugins looks into key 'sourceFilepaths' and validate if paths there actually exist on disk.</p> <p>Also validate if the key is filled but is empty. In that case also crashes so do not fill the key if unfilled value should not cause error.</p> <p>This is primarily created for Simple Creator instances.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/validate_filepaths.py</code> <pre><code>class ValidateFilePath(pyblish.api.InstancePlugin):\n    \"\"\"Validate existence of source filepaths on instance.\n\n    Plugins looks into key 'sourceFilepaths' and validate if paths there\n    actually exist on disk.\n\n    Also validate if the key is filled but is empty. In that case also\n    crashes so do not fill the key if unfilled value should not cause error.\n\n    This is primarily created for Simple Creator instances.\n    \"\"\"\n\n    label = \"Validate Filepaths\"\n    order = pyblish.api.ValidatorOrder - 0.49\n\n    hosts = [\"traypublisher\"]\n\n    def process(self, instance):\n        if \"sourceFilepaths\" not in instance.data:\n            self.log.info((\n                \"Skipped validation of source filepaths existence.\"\n                \" Instance does not have collected 'sourceFilepaths'\"\n            ))\n            return\n\n        product_type = instance.data[\"productType\"]\n        label = instance.data[\"name\"]\n        filepaths = instance.data[\"sourceFilepaths\"]\n        if not filepaths:\n            raise PublishValidationError(\n                (\n                    \"Source filepaths of '{}' instance \\\"{}\\\" are not filled\"\n                ).format(product_type, label),\n                \"File not filled\",\n                (\n                    \"## Files were not filled\"\n                    \"\\nThis mean that you didn't enter any files into required\"\n                    \" file input.\"\n                    \"\\n- Please refresh publishing and check instance\"\n                    \" &lt;b&gt;{}&lt;/b&gt;\"\n                ).format(label)\n            )\n\n        not_found_files = [\n            filepath\n            for filepath in filepaths\n            if not os.path.exists(filepath)\n        ]\n        if not_found_files:\n            joined_paths = \"\\n\".join([\n                \"- {}\".format(filepath)\n                for filepath in not_found_files\n            ])\n            raise PublishValidationError(\n                (\n                    \"Filepath of '{}' instance \\\"{}\\\" does not exist:\\n{}\"\n                ).format(product_type, label, joined_paths),\n                \"File not found\",\n                (\n                    \"## Files were not found\\nFiles\\n{}\"\n                    \"\\n\\nCheck if the path is still available.\"\n                ).format(joined_paths)\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_frame_ranges.html","title":"validate_frame_ranges","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_frame_ranges.html#client.ayon_traypublisher.plugins.publish.validate_frame_ranges.ValidateFrameRange","title":"<code>ValidateFrameRange</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Validating frame range of rendered files against state in DB.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/validate_frame_ranges.py</code> <pre><code>class ValidateFrameRange(OptionalPyblishPluginMixin,\n                         pyblish.api.InstancePlugin):\n    \"\"\"Validating frame range of rendered files against state in DB.\"\"\"\n\n    label = \"Validate Frame Range\"\n    hosts = [\"traypublisher\"]\n    families = [\"render\", \"plate\"]\n    targets = [\"local\"]\n\n    order = ValidateContentsOrder\n\n    optional = True\n    # published data might be sequence (.mov, .mp4) in that counting files\n    # doesn't make sense\n    check_extensions = [\"exr\", \"dpx\", \"jpg\", \"jpeg\", \"png\", \"tiff\", \"tga\",\n                        \"gif\", \"svg\", \"sxr\"]\n    skip_timelines_check = []  # skip for specific task names (regex)\n\n    def process(self, instance):\n        # Skip the instance if is not active by data on the instance\n        if not self.is_active(instance.data):\n            return\n\n        # editorial would fail since they might not be in database yet\n        new_hierarchy = (\n            instance.data.get(\"newHierarchyIntegration\")\n            # Backwards compatible (Deprecated since 24/06/06)\n            or instance.data.get(\"newAssetPublishing\")\n        )\n        if new_hierarchy:\n            self.log.debug(\"Instance is creating new folder. Skipping.\")\n            return\n\n        if (self.skip_timelines_check and\n            any(re.search(pattern, instance.data[\"task\"])\n                for pattern in self.skip_timelines_check)):\n            self.log.info(\"Skipping for {} task\".format(instance.data[\"task\"]))\n\n        # Use attributes from task entity if set, otherwise from folder entity\n        entity = (\n            instance.data.get(\"taskEntity\") or instance.data[\"folderEntity\"]\n        )\n        attributes = entity[\"attrib\"]\n        frame_start = attributes[\"frameStart\"]\n        frame_end = attributes[\"frameEnd\"]\n        handle_start = attributes[\"handleStart\"]\n        handle_end = attributes[\"handleEnd\"]\n        duration = (frame_end - frame_start + 1) + handle_start + handle_end\n\n        repres = instance.data.get(\"representations\")\n        if not repres:\n            self.log.info(\"No representations, skipping.\")\n            return\n\n        first_repre = repres[0]\n        ext = first_repre['ext'].replace(\".\", '')\n\n        if not ext or ext.lower() not in self.check_extensions:\n            self.log.warning(\"Cannot check for extension {}\".format(ext))\n            return\n\n        files = first_repre[\"files\"]\n        if isinstance(files, str):\n            files = [files]\n        frames = len(files)\n\n        msg = (\n            \"Frame duration from DB:'{}' doesn't match number of files:'{}'\"\n            \" Please change frame range for folder/task or limit no. of files\"\n        ). format(int(duration), frames)\n\n        formatting_data = {\"duration\": duration,\n                           \"found\": frames}\n        if frames != duration:\n            raise PublishXmlValidationError(self, msg,\n                                            formatting_data=formatting_data)\n\n        self.log.debug(\"Valid ranges expected '{}' - found '{}'\".\n                       format(int(duration), frames))\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_online_file.html","title":"validate_online_file","text":""},{"location":"autoapi/client/ayon_traypublisher/plugins/publish/validate_online_file.html#client.ayon_traypublisher.plugins.publish.validate_online_file.ValidateOnlineFile","title":"<code>ValidateOnlineFile</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Validate that product doesn't exist yet.</p> Source code in <code>client/ayon_traypublisher/plugins/publish/validate_online_file.py</code> <pre><code>class ValidateOnlineFile(OptionalPyblishPluginMixin,\n                         pyblish.api.InstancePlugin):\n    \"\"\"Validate that product doesn't exist yet.\"\"\"\n    label = \"Validate Existing Online Files\"\n    hosts = [\"traypublisher\"]\n    families = [\"online\"]\n    order = ValidateContentsOrder\n\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        project_name = instance.context.data[\"projectName\"]\n        folder_id = instance.data[\"folderEntity\"][\"id\"]\n        product_entity = ayon_api.get_product_by_name(\n            project_name, instance.data[\"productName\"], folder_id)\n\n        if product_entity:\n            raise PublishValidationError(\n                \"Product to be published already exists.\",\n                title=self.label\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/ui/index.html","title":"ui","text":""},{"location":"autoapi/client/ayon_traypublisher/ui/window.html","title":"window","text":"<p>Tray publisher is extending publisher tool.</p> <p>Adds ability to select project using overlay widget with list of projects.</p> <p>Tray publisher can be considered as host implementeation with creators and publishing plugins.</p>"},{"location":"autoapi/client/ayon_traypublisher/ui/window.html#client.ayon_traypublisher.ui.window.ChooseProjectController","title":"<code>ChooseProjectController</code>","text":"Source code in <code>client/ayon_traypublisher/ui/window.py</code> <pre><code>class ChooseProjectController:\n    def __init__(self):\n        self._event_system = QueuedEventSystem()\n        self._projects_model = ProjectsModel(self)\n        self._registry = AYONSettingsRegistry(\"traypublisher\")\n\n    def get_project_items(self, sender=None):\n        return self._projects_model.get_project_items(sender)\n\n    def emit_event(self, topic, data=None, source=None):\n        \"\"\"Use implemented event system to trigger event.\"\"\"\n\n        if data is None:\n            data = {}\n        self._event_system.emit(topic, data, source)\n\n    def register_event_callback(self, topic, callback):\n        self._event_system.add_callback(topic, callback)\n\n    def get_last_user_project_name(self) -&gt; Optional[str]:\n        try:\n            return self._registry.get_item(\"project_name\")\n        except ValueError:\n            pass\n\n    def set_last_user_project_name(self, project_name: str):\n        self._registry.set_item(\"project_name\", project_name)\n</code></pre>"},{"location":"autoapi/client/ayon_traypublisher/ui/window.html#client.ayon_traypublisher.ui.window.ChooseProjectController.emit_event","title":"<code>emit_event(topic, data=None, source=None)</code>","text":"<p>Use implemented event system to trigger event.</p> Source code in <code>client/ayon_traypublisher/ui/window.py</code> <pre><code>def emit_event(self, topic, data=None, source=None):\n    \"\"\"Use implemented event system to trigger event.\"\"\"\n\n    if data is None:\n        data = {}\n    self._event_system.emit(topic, data, source)\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/index.html#server.Traypublisher","title":"<code>Traypublisher</code>","text":"<p>               Bases: <code>BaseServerAddon</code></p> Source code in <code>server/__init__.py</code> <pre><code>class Traypublisher(BaseServerAddon):\n    settings_model = TraypublisherSettings\n\n    async def get_default_settings(self):\n        settings_model_cls = self.get_settings_model()\n        return settings_model_cls(**DEFAULT_TRAYPUBLISHER_SETTING)\n\n    async def get_simple_actions(\n        self,\n        project_name: str | None = None,\n        variant: str = \"production\",\n    ) -&gt; list[\"SimpleActionManifest\"]:\n        if not project_name:\n            return []\n        icon = {\n            \"type\": \"material-symbols\",\n            \"name\": \"upload_2\",\n            \"color\": \"#ffffff\",\n        }\n        kwargs = {\n            \"label\": \"Tray Publisher\",\n            \"category\": \"Desktop tools\",\n            \"icon\": icon,\n            \"order\": 100,\n            \"entity_subtypes\": None,\n            \"allow_multiselection\": False,\n        }\n        return [\n            SimpleActionManifest(\n                identifier=\"traypublisher.project\",\n                entity_type=\"project\",\n                **kwargs\n            ),\n            SimpleActionManifest(\n                identifier=\"traypublisher.folder\",\n                entity_type=\"folder\",\n                **kwargs\n            ),\n            SimpleActionManifest(\n                identifier=\"traypublisher.task\",\n                entity_type=\"task\",\n                **kwargs\n            ),\n        ]\n\n    async def execute_action(\n        self,\n        executor: \"ActionExecutor\",\n    ) -&gt; \"ExecuteResponseModel\":\n        \"\"\"Execute an action provided by the addon\"\"\"\n        context = executor.context\n        project_name = context.project_name\n\n        return await executor.get_launcher_action_response(\n            args=[\n                \"addon\", \"traypublisher\",\n                \"launch\", \"--project\", project_name,\n            ]\n        )\n</code></pre>"},{"location":"autoapi/server/index.html#server.Traypublisher.execute_action","title":"<code>execute_action(executor)</code>  <code>async</code>","text":"<p>Execute an action provided by the addon</p> Source code in <code>server/__init__.py</code> <pre><code>async def execute_action(\n    self,\n    executor: \"ActionExecutor\",\n) -&gt; \"ExecuteResponseModel\":\n    \"\"\"Execute an action provided by the addon\"\"\"\n    context = executor.context\n    project_name = context.project_name\n\n    return await executor.get_launcher_action_response(\n        args=[\n            \"addon\", \"traypublisher\",\n            \"launch\", \"--project\", project_name,\n        ]\n    )\n</code></pre>"},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/index.html#server.settings.TraypublisherSettings","title":"<code>TraypublisherSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Traypublisher Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class TraypublisherSettings(BaseSettingsModel):\n    \"\"\"Traypublisher Project Settings.\"\"\"\n    imageio: TrayPublisherImageIOModel = SettingsField(\n        default_factory=TrayPublisherImageIOModel,\n        title=\"Color Management (ImageIO)\"\n    )\n    simple_creators: list[SimpleCreatorPlugin] = SettingsField(\n        title=\"Simple Create Plugins\",\n        default_factory=SimpleCreatorPlugin,\n    )\n    editorial_creators: TraypublisherEditorialCreatorPlugins = SettingsField(\n        title=\"Editorial Creators\",\n        default_factory=TraypublisherEditorialCreatorPlugins,\n    )\n    create: TrayPublisherCreatePluginsModel = SettingsField(\n        title=\"Create\",\n        default_factory=TrayPublisherCreatePluginsModel\n    )\n    publish: TrayPublisherPublishPlugins = SettingsField(\n        title=\"Publish Plugins\",\n        default_factory=TrayPublisherPublishPlugins\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html","title":"creator_plugins","text":""},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.BatchMovieCreatorPlugin","title":"<code>BatchMovieCreatorPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Allows to publish multiple video files in one go. Name of matching asset is parsed from file names ('asset.mov', 'asset_v001.mov', 'my_asset_to_publish.mov')</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class BatchMovieCreatorPlugin(BaseSettingsModel):\n    \"\"\"Allows to publish multiple video files in one go. &lt;br /&gt;Name of matching\n     asset is parsed from file names ('asset.mov', 'asset_v001.mov',\n     'my_asset_to_publish.mov')\"\"\"\n\n    default_variants: list[str] = SettingsField(\n        title=\"Default variants\",\n        default_factory=list\n    )\n\n    default_tasks: list[str] = SettingsField(\n        title=\"Default tasks\",\n        default_factory=list\n    )\n\n    extensions: list[str] = SettingsField(\n        title=\"Extensions\",\n        default_factory=list\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.ColumnConfigModel","title":"<code>ColumnConfigModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Allows to publish multiple video files in one go. Name of matching asset is parsed from file names ('asset.mov', 'asset_v001.mov', 'my_asset_to_publish.mov')</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class ColumnConfigModel(BaseSettingsModel):\n    \"\"\"Allows to publish multiple video files in one go. &lt;br /&gt;Name of matching\n     asset is parsed from file names ('asset.mov', 'asset_v001.mov',\n     'my_asset_to_publish.mov')\"\"\"\n\n    csv_delimiter: str = SettingsField(\n        title=\"CSV delimiter\",\n        default=\",\"\n    )\n\n    columns: list[ColumnItemModel] = SettingsField(\n        title=\"Columns\",\n        default_factory=list\n    )\n\n    @validator(\"columns\")\n    def validate_unique_outputs(cls, value):\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.ColumnItemModel","title":"<code>ColumnItemModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Allows to publish multiple video files in one go. Name of matching asset is parsed from file names ('asset.mov', 'asset_v001.mov', 'my_asset_to_publish.mov')</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class ColumnItemModel(BaseSettingsModel):\n    \"\"\"Allows to publish multiple video files in one go. &lt;br /&gt;Name of matching\n     asset is parsed from file names ('asset.mov', 'asset_v001.mov',\n     'my_asset_to_publish.mov')\"\"\"\n\n    _layout = \"expanded\"\n    name: str = SettingsField(\n        title=\"Name\",\n        default=\"\"\n    )\n\n    type: str = SettingsField(\n        title=\"Type\",\n        default=\"\"\n    )\n\n    default: str = SettingsField(\n        title=\"Default\",\n        default=\"\"\n    )\n\n    required_column: bool = SettingsField(\n        title=\"Required Column\",\n        default=False\n    )\n\n    validation_pattern: str = SettingsField(\n        title=\"Validation Regex Pattern\",\n        default=\"^(.*)$\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.FolderCreationConfigModel","title":"<code>FolderCreationConfigModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Allow to create folder hierarchy when non-existing.</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class FolderCreationConfigModel(BaseSettingsModel):\n    \"\"\"Allow to create folder hierarchy when non-existing.\"\"\"\n\n    enabled: bool = SettingsField(\n        title=\"Enabled folder creation\",\n        default=False,\n    )\n    folder_create_type: str = SettingsField(\n        \"Folder\",\n        title=\"Default Folder Type\",\n        enum_resolver=folder_types_enum,\n        description=(\n            \"Default folder type for new folder(s) creation.\"),\n        section=\"Folder Settings\"\n    )\n    folder_type_regexes: list[FolderTypeRegexItem] = SettingsField(\n        default_factory=FolderTypeRegexItem,\n        description=(\n            \"Using Regex expressions to create missing folders. \\nThose can be used\"\n            \" to define which folder types are used for new folder creation\"\n            \" depending on their names.\"\n        )\n    )\n    task_create_type: str = SettingsField(\n        \"\",\n        title=\"Default Task Type\",\n        enum_resolver=task_types_enum,\n        description=(\n            \"Default task type for new task(s) creation.\"),\n        section=\"Task Settings\"\n    )\n    task_type_regexes: list[TaskTypeRegexItem] = SettingsField(\n        default_factory=TaskTypeRegexItem,\n        description=(\n            \"Using Regex expressions to create missing tasks. \\nThose can be used\"\n            \" to define which task types are used for new folder+task creation\"\n            \" depending on their names.\"\n        )\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.IngestCSVPluginModel","title":"<code>IngestCSVPluginModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Allows to publish multiple video files in one go. Name of matching asset is parsed from file names ('asset.mov', 'asset_v001.mov', 'my_asset_to_publish.mov')</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class IngestCSVPluginModel(BaseSettingsModel):\n    \"\"\"Allows to publish multiple video files in one go. &lt;br /&gt;Name of matching\n     asset is parsed from file names ('asset.mov', 'asset_v001.mov',\n     'my_asset_to_publish.mov')\"\"\"\n\n    enabled: bool = SettingsField(\n        title=\"Enabled\",\n        default=False\n    )\n\n    columns_config: ColumnConfigModel = SettingsField(\n        title=\"Columns config\",\n        default_factory=ColumnConfigModel\n    )\n\n    representations_config: RepresentationConfigModel = SettingsField(\n        title=\"Representations config\",\n        default_factory=RepresentationConfigModel\n    )\n\n    folder_creation_config: FolderCreationConfigModel = SettingsField(\n        title=\"Folder creation config\",\n        default_factory=FolderCreationConfigModel\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.RepresentationConfigModel","title":"<code>RepresentationConfigModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Allows to publish multiple video files in one go. Name of matching asset is parsed from file names ('asset.mov', 'asset_v001.mov', 'my_asset_to_publish.mov')</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class RepresentationConfigModel(BaseSettingsModel):\n    \"\"\"Allows to publish multiple video files in one go. &lt;br /&gt;Name of matching\n     asset is parsed from file names ('asset.mov', 'asset_v001.mov',\n     'my_asset_to_publish.mov')\"\"\"\n\n    tags_delimiter: str = SettingsField(\n        title=\"Tags delimiter\",\n        default=\";\"\n    )\n\n    default_tags: list[str] = SettingsField(\n        title=\"Default tags\",\n        default_factory=list\n    )\n\n    representations: list[RepresentationItemModel] = SettingsField(\n        title=\"Representations\",\n        default_factory=list\n    )\n\n    @validator(\"representations\")\n    def validate_unique_outputs(cls, value):\n        ensure_unique_names(value)\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html#server.settings.creator_plugins.RepresentationItemModel","title":"<code>RepresentationItemModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Allows to publish multiple video files in one go.</p> <p>Name of matching asset is parsed from file names ('asset.mov', 'asset_v001.mov', 'my_asset_to_publish.mov')</p> Source code in <code>server/settings/creator_plugins.py</code> <pre><code>class RepresentationItemModel(BaseSettingsModel):\n    \"\"\"Allows to publish multiple video files in one go.\n\n    Name of matching asset is parsed from file names\n    ('asset.mov', 'asset_v001.mov', 'my_asset_to_publish.mov')\n    \"\"\"\n\n    _layout = \"expanded\"\n    name: str = SettingsField(\n        title=\"Name\",\n        default=\"\"\n    )\n\n    extensions: list[str] = SettingsField(\n        title=\"Extensions\",\n        default_factory=list\n    )\n\n    @validator(\"extensions\")\n    def validate_extension(cls, value):\n        for ext in value:\n            if not ext.startswith(\".\"):\n                raise BadRequestException(f\"Extension must start with '.': {ext}\")\n        return value\n</code></pre>"},{"location":"autoapi/server/settings/editorial_creators.html","title":"editorial_creators","text":""},{"location":"autoapi/server/settings/editorial_creators.html#server.settings.editorial_creators.RepresentationAdvancedItemModel","title":"<code>RepresentationAdvancedItemModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Representation advanced settings.</p> <p>Configuration used for filtering rules so files in folder are converted to publishable representations with correct data definitions.</p> Source code in <code>server/settings/editorial_creators.py</code> <pre><code>class RepresentationAdvancedItemModel(BaseSettingsModel):\n    \"\"\"Representation advanced settings.\n\n    Configuration used for filtering rules so files in folder are converted to\n    publishable representations with correct data definitions.\n    \"\"\"\n\n    name: str = SettingsField(title=\"Name\", default=\"\")\n    content_type: str = SettingsField(\n        \"video\",\n        title=\"Content type\",\n        enum_resolver=get_content_type_enum,\n    )\n    extensions: list[str] = SettingsField(\n        title=\"Filter by extensions\",\n        default_factory=list,\n        description=(\n            \"Only files with these extensions will be published. \"\n            \"following are accepted: .ext, ext, EXT, .EXT\"\n        ),\n        section=\"Filtering options\",\n    )\n    patterns: list[str] = SettingsField(\n        title=\"Filter by patterns\",\n        default_factory=list,\n        description=(\n            \"Regular expression patterns to filter files. \"\n            \"Search in filenames for matching files.\"\n        ),\n    )\n    tags: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Tags\",\n        description=(\n            \"Tags that will be added to the created representation.\"\n            \"\\nAdd *review* tag to create review from the transcoded\"\n            \" representation instead of the original.\"\n        ),\n        section=\"Representation options\",\n    )\n    custom_tags: list[str] = SettingsField(\n        title=\"Custom tags\",\n        default_factory=list,\n        description=(\n            \"Additional custom tags can be used for advanced filtering \"\n            \"in Extract Review output presets.\"\n        ),\n    )\n</code></pre>"},{"location":"autoapi/server/settings/editorial_creators.html#server.settings.editorial_creators.ShotHierarchySubmodel","title":"<code>ShotHierarchySubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Shot Hierarchy Info</p> <p>Shot Hierarchy defines the folder path where each shot will be added. It uses the <code>Folder path template</code> to compute each path. The <code>Folder path template</code> supports tokens defined in the <code>folder path template tokens</code> setting.</p> <ul> <li>Each token in the <code>Folder path template</code> represents a folder in the hierarchy.</li> <li>Each token's value supports both the available template keys and tokens defined under <code>Clip Name Tokenizer</code>.</li> </ul> Source code in <code>server/settings/editorial_creators.py</code> <pre><code>class ShotHierarchySubmodel(BaseSettingsModel):\n    \"\"\"Shot Hierarchy Info\n\n    Shot Hierarchy defines the folder path where each shot will be added.\n    It uses the `Folder path template` to compute each path.\n    The `Folder path template` supports tokens defined in the `folder path template tokens` setting.\n\n    - Each token in the `Folder path template` represents a folder in the hierarchy.\n    - Each token's value supports both the available\n    [template keys](https://ayon.ynput.io/docs/admin_settings_project_anatomy#available-template-keys)\n    and tokens defined under `Clip Name Tokenizer`.\n    \"\"\"\n    enabled: bool = True\n    parents_path: str = SettingsField(\n        \"\",\n        title=\"Folder path template\"\n    )\n    parents: list[TokenToParentConvertorItem] = SettingsField(\n        default_factory=TokenToParentConvertorItem,\n        title=\"Folder path template tokens\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/editorial_creators.html#server.settings.editorial_creators.ShotRenameSubmodel","title":"<code>ShotRenameSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Shot Rename Info</p> <p>When enabled, any discovered shots will be renamed based on the <code>shot rename template</code>.</p> <p>The template supports both the available template keys and tokens defined under <code>Clip Name Tokenizer</code>.</p> Source code in <code>server/settings/editorial_creators.py</code> <pre><code>class ShotRenameSubmodel(BaseSettingsModel):\n    \"\"\"Shot Rename Info\n\n    When enabled, any discovered shots will be renamed based on the `shot rename template`.\n\n    The template supports both the available\n    [template keys](https://ayon.ynput.io/docs/admin_settings_project_anatomy#available-template-keys)\n    and tokens defined under `Clip Name Tokenizer`.\n    \"\"\"\n    enabled: bool = True\n    shot_rename_template: str = SettingsField(\n        \"\",\n        title=\"Shot rename template\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.TraypublisherSettings","title":"<code>TraypublisherSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Traypublisher Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class TraypublisherSettings(BaseSettingsModel):\n    \"\"\"Traypublisher Project Settings.\"\"\"\n    imageio: TrayPublisherImageIOModel = SettingsField(\n        default_factory=TrayPublisherImageIOModel,\n        title=\"Color Management (ImageIO)\"\n    )\n    simple_creators: list[SimpleCreatorPlugin] = SettingsField(\n        title=\"Simple Create Plugins\",\n        default_factory=SimpleCreatorPlugin,\n    )\n    editorial_creators: TraypublisherEditorialCreatorPlugins = SettingsField(\n        title=\"Editorial Creators\",\n        default_factory=TraypublisherEditorialCreatorPlugins,\n    )\n    create: TrayPublisherCreatePluginsModel = SettingsField(\n        title=\"Create\",\n        default_factory=TrayPublisherCreatePluginsModel\n    )\n    publish: TrayPublisherPublishPlugins = SettingsField(\n        title=\"Publish Plugins\",\n        default_factory=TrayPublisherPublishPlugins\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ExtractEditorialPckgConversionModel","title":"<code>ExtractEditorialPckgConversionModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Set output definition if resource files should be converted.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ExtractEditorialPckgConversionModel(BaseSettingsModel):\n    \"\"\"Set output definition if resource files should be converted.\"\"\"\n    conversion_enabled: bool = SettingsField(True,\n                                             title=\"Conversion enabled\")\n    output: ExtractEditorialPckgOutputDefModel = SettingsField(\n        default_factory=ExtractEditorialPckgOutputDefModel,\n        title=\"Output Definitions\",\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateFrameRangeModel","title":"<code>ValidateFrameRangeModel</code>","text":"<p>               Bases: <code>ValidatePluginModel</code></p> <p>Allows to publish multiple video files in one go. Name of matching asset is parsed from file names ('asset.mov', 'asset_v001.mov', 'my_asset_to_publish.mov')</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateFrameRangeModel(ValidatePluginModel):\n    \"\"\"Allows to publish multiple video files in one go. &lt;br /&gt;Name of matching\n     asset is parsed from file names ('asset.mov', 'asset_v001.mov',\n     'my_asset_to_publish.mov')\"\"\"\n</code></pre>"},{"location":"autoapi/server/settings/simple_creators.html","title":"simple_creators","text":""}]}